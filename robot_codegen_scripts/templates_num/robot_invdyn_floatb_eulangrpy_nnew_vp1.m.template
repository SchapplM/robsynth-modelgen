% Calculate vector of inverse dynamics base and joint forces/torques for a
% %RN%
% Use numerical implementation of recursive Newton-Euler Algorithm
% 
% Input:
% q [%NJ%x1]
%   Joint Angles [rad]
% qD [%NJ%x1]
%   Joint Velocities [rad/s]
% phi_base [3x1]
%   Base orientation in world frame. Expressed with RPY Euler angles (xyz)
% xD_base [6x1]
%   time derivative of 
%   r_base (3x1 Base position in world frame) and 
%   phi_base (3x1)
% a_mdh, d_mdh, q_offset_mdh [%NJ%x1]
%   kinematic parameters
% m_num_mdh [%NL%x1], rSges_num_mdh [%NL%x3], Icges_num_mdh [%NL%x6]
%   dynamic parameters (parameter set 1: center of mass in link frame and 
%   inertia about center of mass. Order: xx, yy, zz, xy, xz, yz)
% 
% Output:
% tau [(6+%NJ%)x1]
%   base forces and joint torques required to compensate inverse dynamics
%   base moments in generalized coordinates (euler-RPY)
% 
% See also:
% IRT-Matlab-Toolbox: dynamics/robot_tree_invdyn_floatb_eulangrpy_nnew_vp1.m

function [tau, v_i_i_ges, w_i_i_ges] = %FN%(q, qD, qDD, phi_base, xD_base, xDD_base, ...
  alpha_mdh, a_mdh, d_mdh, q_offset_mdh, b_mdh, beta_mdh, v_mdh, m_num, rSges_num_mdh, Icges_num_mdh)

%%Coder Information
%#codegen
assert(isa(q,'double') && isreal(q) && all(size(q) == [%NJ% 1]), ...
  '%FN%: q has to be [%NJ%x1] double');
assert(isa(qD,'double') && isreal(qD) && all(size(qD) == [%NJ% 1]), ...
  '%FN%: qD has to be [%NJ%x1] double');
assert(isa(qDD,'double') && isreal(qDD) && all(size(qDD) == [%NJ% 1]), ...
  '%FN%: qDD has to be [%NJ%x1] double');
assert(isa(phi_base,'double') && isreal(phi_base) && all(size(phi_base) == [3 1]), ...
  '%FN%: phi_base has to be [3x1] double');
assert(isa(xD_base,'double') && isreal(xD_base) && all(size(xD_base) == [6 1]), ...
  '%FN%: xD_base has to be [6x1] double');
assert(isa(xDD_base,'double') && isreal(xDD_base) && all(size(xDD_base) == [6 1]), ...
  '%FN%: xDD_base has to be [6x1] double');
assert(isa(alpha_mdh,'double') && isreal(alpha_mdh) && all(size(alpha_mdh) == [%NJ% 1]), ...
  '%FN%: alpha_mdh has to be [%NJ%x1] double');
assert(isa(a_mdh,'double') && isreal(a_mdh) && all(size(a_mdh) == [%NJ% 1]), ...
  '%FN%: a_mdh has to be [%NJ%x1] double');
assert(isa(d_mdh,'double') && isreal(d_mdh) && all(size(d_mdh) == [%NJ% 1]), ...
  '%FN%: d_mdh has to be [%NJ%x1] double');
assert(isa(q_offset_mdh,'double') && isreal(q_offset_mdh) && all(size(q_offset_mdh) == [%NJ% 1]), ...
  '%FN%: q_offset_mdh has to be [%NJ%x1] double');
assert(isa(b_mdh,'double') && isreal(b_mdh) && all(size(b_mdh) == [%NJ% 1]), ...
  '%FN%: b_mdh has to be [%NJ%x1] double');
assert(isa(beta_mdh,'double') && isreal(beta_mdh) && all(size(beta_mdh) == [%NJ% 1]), ...
  '%FN%: beta_mdh has to be [%NJ%x1] double');
assert(isa(v_mdh,'uint8') && all(size(v_mdh) == [%NJ% 1]), ...
  '%FN%: v_mdh has to be [%NJ%x1] uint8'); 
assert(isa(m_num,'double') && isreal(m_num) && all(size(m_num) == [%NL% 1]), ...
  '%FN%: m_num has to be [%NL%x1] double'); 
assert(isa(rSges_num_mdh,'double') && isreal(rSges_num_mdh) && all(size(rSges_num_mdh) == [%NL%,3]), ...
  '%FN%: rSges_num_mdh has to be [%NL%x3] double');
assert(isa(Icges_num_mdh,'double') && isreal(Icges_num_mdh) && all(size(Icges_num_mdh) == [%NL% 6]), ...
  '%FN%: Icges_num_mdh has to be [%NL%x6] double'); 

%% Init
tau_J = NaN(%NJ%,1);
R_W_0 = rpy2r(phi_base(1), phi_base(2), phi_base(3));
T_basevel = rpy2jac(phi_base(1), phi_base(2), phi_base(3));

%% Vorwärts-Iteration
% Positionen. Berechne symbolisch (effizienter).
T_mdh = %RN%_joint_trafo_rotmat_mdh_sym_varpar(q, ...
  alpha_mdh, a_mdh, d_mdh, q_offset_mdh, b_mdh, beta_mdh);

% Geschwindigkeiten
v_i_i_ges = NaN(3,%NL%);
w_i_i_ges = NaN(3,%NL%);

% Beschleunigungen
vD_i_i_ges = NaN(3,%NL%);
wD_i_i_ges = NaN(3,%NL%);

% Anfangswerte: Geschwindigkeit und Beschleunigung der Basis
v_i_i_ges(:,1) = R_W_0'*xD_base(1:3);
w_i_i_ges(:,1) = R_W_0'*rpyD2omega(phi_base', xD_base(4:6)')';

vD_i_i_ges(:,1) = R_W_0'*xDD_base(1:3);
wD_i_i_ges(:,1) = R_W_0'*rpyDD2omegaD(phi_base', xD_base(4:6)', xDD_base(4:6)')';

for i = 2:%NL%
  % Nummer des Vorgänger-Segments
  j = v_mdh(i-1)+1; % Gelenk 1 führt zu Körper 2 (Matlab-Indizes) usw.
  
  % Temporäre Ausdrücke belegen
  v_j_j = v_i_i_ges(:,j);
  w_j_j = w_i_i_ges(:,j);
  vD_j_j = vD_i_i_ges(:,j);
  wD_j_j = wD_i_i_ges(:,j);
  R_j_i = T_mdh(1:3,1:3,i-1);
  r_j_j_i = T_mdh(1:3,4,i-1);
  
  % Berechnung
  w_i_i = R_j_i'*w_j_j + [0;0;1]*qD(i-1);
  v_i_i = R_j_i'*( v_j_j + cross(w_j_j, r_j_j_i) );
  
  wD_i_i = R_j_i'*wD_j_j + [0;0;1]*qDD(i-1) + cross(R_j_i'*w_j_j, [0;0;1]*qD(i-1));
  vD_i_i = R_j_i'*( vD_j_j + cross(wD_j_j, r_j_j_i) +cross(w_j_j, cross(w_j_j, r_j_j_i)) );
  
  % Ausgabeausdrücke belegen
  v_i_i_ges(:,i) = v_i_i;
  w_i_i_ges(:,i) = w_i_i;
  vD_i_i_ges(:,i) = vD_i_i;
  wD_i_i_ges(:,i) = wD_i_i;
end


%% Rückwärts-Rekursion
f_i_i_ges = NaN(3,%NL%);
n_i_i_ges = NaN(3,%NL%);

for i = %NL%:-1:1
  % Temporäre Ausdrücke belegen
  vD_i_i = vD_i_i_ges(:,i);
  w_i_i = w_i_i_ges(:,i);
  wD_i_i = wD_i_i_ges(:,i);
  c_i = rSges_num_mdh(i,:)';
  I_i = inertiavector2matrix(Icges_num_mdh(i,:));
  
  % Dynamik-Terme
  F_i = m_num(i)*(vD_i_i + cross(wD_i_i, c_i) + cross( w_i_i,cross(w_i_i, c_i)) );
  N_i = I_i*wD_i_i + cross(w_i_i, I_i*w_i_i);
  
  f_i_i = F_i;
  n_i_i = N_i + cross(c_i, F_i);
  
  % Suche alle Nachfolger und addiere das Schnittmoment
  I_nf = find( (v_mdh == (i-1)) ) + 1;
   % Wähle diese Konstruktion um Schleifen mit variabler Länge zu vermeiden (Kompilierbarkeit)
  if ~isempty(I_nf)
    for tmp = 1:length(v_mdh) % Index des Nachfolgers
      j = I_nf(tmp);
      R_i_j = T_mdh(1:3,1:3,j-1);
      f_j_j = f_i_i_ges(:,j);
      n_j_j = n_i_i_ges(:,j);
      r_i_i_j = T_mdh(1:3,4,j-1);
      
      f_i_i = f_i_i + R_i_j*f_j_j;
      n_i_i = n_i_i + R_i_j*n_j_j + cross(r_i_i_j, R_i_j*f_j_j);
      if tmp == length(I_nf)
        break; % Abbruch. Alle Nachfolger untersucht.
      end
    end
  end
  
  % Ausgabeausdrücke belegen
  f_i_i_ges(:,i) = f_i_i;
  n_i_i_ges(:,i) = n_i_i; 
end

%% Projektion auf die Gelenke
for i = 2:%NL%
  tau_J(i-1) = [0 0 1] * n_i_i_ges(:,i);
end

%% Basis-Kraft
tau_B = [R_W_0*f_i_i_ges(:,1); T_basevel' * R_W_0*n_i_i_ges(:,1)]; 

%% Ausgabe
tau = [tau_B; tau_J];
