% Teste parameterlineare Formen der Dynamik für parallele Roboter

% %VERSIONINFO%

% Tim Job (Studienarbeit bei Moritz Schappler), 2018-12
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de
% (C) Institut für Mechatronische Systeme, Universität Hannover

clc
clear

NQJ = %NQJ_P%;
N_LEGS = %N_LEGS%; % number of legs
N_XP = %N_XP%; % number of platform DOF
robot_name = '%RN%';

%% Parameter
TSS = %RN%_varpar_testfunctions_parameter_par();
for f = fields(TSS)'
  eval(sprintf('%s=TSS.%s;',f{1},f{1}));
end

% Minimalparametervektor
MPV = %RN%_minimal_parameter_para(pkin, m, mrSges, Ifges, koppelP);
% Vektor mit Inertialparametern (ohne Parameter nach dem Koppelgelenk, dann mit Plattform-Parametern)
PV2 = NaN(10*size(Ifges,1),1);
for i = 1:size(Ifges,1)
  % different order:
  % Ifges_num_mdh: XX,YY,ZZ,XY,XZ,YZ
  % PV2: XX,XY,XZ,YY,YZ,ZZ
  PV2((1:6) +10*(i-1))   = Ifges(i,[1,4,5,2,6,3]);
  PV2((1:3) +10*(i-1)+6) = mrSges(i,:);
  PV2(10*i)              = m(i);
end
% Liste der Namen der Dynamikparameter. Basis wird hier nicht betrachtet
% (Index "0"), aber bei den Körpern NL mitgezählt.
PV2_Names = cell(10*size(Ifges,1),1);
for i = 1:size(Ifges,1)
  if i == size(Ifges,1)
    name_i = 'P';
  else
    name_i = sprintf('%d', i);
  end
  PV2_Names{10*(i-1)+ 1} = sprintf('XX%s', name_i);
  PV2_Names{10*(i-1)+ 2} = sprintf('XY%s', name_i);
  PV2_Names{10*(i-1)+ 3} = sprintf('XZ%s', name_i);
  PV2_Names{10*(i-1)+ 4} = sprintf('YY%s', name_i);
  PV2_Names{10*(i-1)+ 5} = sprintf('YZ%s', name_i);
  PV2_Names{10*(i-1)+ 6} = sprintf('ZZ%s', name_i);
  PV2_Names{10*(i-1)+ 7} = sprintf('MX%s', name_i);
  PV2_Names{10*(i-1)+ 8} = sprintf('MY%s', name_i);
  PV2_Names{10*(i-1)+ 9} = sprintf('MZ%s', name_i);
  PV2_Names{10*(i-1)+10} = sprintf('M%s',  name_i);
end
%% Test inverse dynamic vs regressor form
Q_GES = length(Q(1,:));
Q_N = Q_GES/NQJ;
for i = 1:n
  q = [];
  for j = 1:Q_N
    q = [q;Q(1,(j-1)*NQJ+1:j*NQJ)]; %#ok<AGROW>
  end
  q = q';
  xP = XP(i,:)';
  xPD = XPD(i,:)';
  xPDD = XPDD(i,:)';
  g = G(i,:)';
  
  Jinv = %RN%_Jinv(xP, q, pkin, koppelP, ...
    legFrame);
  %% Dynamik in Plattform-Koordinaten
  tauX_vp2 = %RN%_invdyn_para_pf_slag_vp2(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  tauX_regmin = %RN%_invdyn_para_pf_regmin(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin);
  tauX_MPV = tauX_regmin*MPV;
  DeltaX = tauX_MPV - tauX_vp2;
  if any(abs(DeltaX) > 1e6*eps(1+max(abs(tauX_MPV))))
    error('Inverse dynamics (platform coordinates) does not match with min. regressor form.')
  end
  tauX_reg2 = %RN%_invdyn_para_pf_reg2(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin);
  DeltaX2 = tauX_reg2*PV2 - tauX_vp2;
  if any(abs(DeltaX2) > 1e6*eps(1+max(abs(tauX_MPV))))
    error('Inverse dynamics (platform coordinates) does not match with inertial regressor form.')
  end
  %% Gravitationsvektor in Plattform-Koordinaten
  taugX_vp2 = %RN%_gravload_para_pf_slag_vp2(xP, q, g, legFrame, ...
    koppelP, pkin, m, mrSges);
  taugX_regmin = %RN%_gravload_para_pf_regmin(xP, q, g, legFrame, ...
    koppelP, pkin);
  taugX_MPV = taugX_regmin*MPV;
  DeltagX = taugX_MPV - taugX_vp2;
  if any(abs(DeltagX) > 1e6*eps(1+max(abs(taugX_MPV))))
    error('Gravload (platform coordinates) does not match with min. regressor form.')
  end
  taugX_reg2 = %RN%_gravload_para_pf_reg2(xP, q, g, legFrame, ...
    koppelP, pkin);
  DeltagX2 = taugX_reg2*PV2 - taugX_vp2;
  if any(abs(DeltagX2) > 1e6*eps(1+max(abs(DeltagX2))))
    error('Gravload (platform coordinates) does not match with inertial regressor form.')
  end
  % Gravitationsvektor-Regressor gegen Dynamik-Regressor
  tauX_regmin = %RN%_invdyn_para_pf_regmin(xP, xPD*0, xPDD*0, q, g, legFrame, ...
    koppelP, pkin);
  Diff_tau_taug = taugX_regmin - tauX_regmin;
  if max(abs(Diff_tau_taug(:))) > 1e3*eps(1+max(abs(tauX_regmin(:))))
    error('Inverse Dynamik Regressor stimmt nicht gegen Gravitation-Regressor');
  end
  
  %% Coriolisvektor in Plattform-Koordinaten
  taucX_vp2 = %RN%_coriolisvec_para_pf_slag_vp2(xP, xPD, q, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  taucX_regmin = %RN%_coriolisvec_para_pf_regmin(xP, xPD, q, legFrame, ...
    koppelP, pkin);
  taucX_MPV = taucX_regmin*MPV;
  DeltacX = taucX_MPV - taucX_vp2;
  if any(abs(DeltacX) > 1e6*eps(1+max(abs(taucX_MPV))))
    error('Coriolis Vector (platform coordinates) does not match with min. regressor form.')
  end
  taucX_reg2 = %RN%_coriolisvec_para_pf_reg2(xP, xPD, q, legFrame, ...
    koppelP, pkin);
  DeltacX2 = taucX_reg2*PV2 - taucX_vp2;
  if any(abs(DeltacX2) > 1e11*eps(1+max(abs(DeltacX2)))) % TODO: Threshold has to be very high
    error('Coriolis Vector (platform coordinates) does not match with inertial regressor form.')
  end
  % Coriolisvektor-Regressor gegen Dynamik-Regressor
  tauX_regmin = %RN%_invdyn_para_pf_regmin(xP, xPD, xPDD*0, q, g*0, legFrame, ...
    koppelP, pkin);
  Diff_tau_tauc = taucX_regmin - tauX_regmin;
  if max(abs(Diff_tau_tauc(:))) > 1e3*eps(1+max(abs(tauX_regmin(:))))
    error('Inverse Dynamik Regressor stimmt nicht gegen Coriolis-Regressor');
  end
  
  
  %% Massenmatrix in Plattform-Koordinaten
  MMX_vp2 = %RN%_inertia_para_pf_slag_vp2(xP, q, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  MMX_regmin = %RN%_inertia_para_pf_regmin(xP, q, legFrame, ...
    koppelP, pkin);
  MMX_MPV_vec = MMX_regmin*MPV;
  MMX_MPV = reshape(MMX_MPV_vec,N_XP,N_XP)';
  DeltaMMX = MMX_MPV - MMX_vp2;
  if any(abs(DeltaMMX(:)) > 1e6*eps(1+max(abs(MMX_MPV(:)))))
    error('Inertia Matrix (platform coordinates) does not match with min. regressor form.')
  end
  MMX_reg2 = %RN%_inertia_para_pf_reg2(xP, q, legFrame, ...
    koppelP, pkin);
  MMX_PV2_vec = MMX_reg2*PV2;
  MMX_PV2 = reshape(MMX_PV2_vec,N_XP,N_XP)';
  DeltaMMX2 = MMX_PV2 - MMX_vp2;
  if any(abs(DeltaMMX2(:)) > 1e6*eps(1+max(abs(DeltaMMX2(:)))))
    error('Inertia Matrix (platform coordinates) does not match with inertial regressor form.')
  end
  
  %% Dynamik in Antriebskoordinaten
  if N_XP <= 4 && ~isempty(fileparts(which('%RN%_invdyn_para_qa_slag_vp2')))
    % nur testen, falls Funktionen auch generiert wurden.
    tauA_vp2 = %RN%_invdyn_para_qa_slag_vp2(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    tauA_reg = %RN%_invdyn_para_qa_regmin(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin);
    tauA_MPV = tauA_reg*MPV;
    DeltaA = tauA_MPV - tauA_vp2;
    if any(abs(DeltaA) > 1e6*eps(1+max(abs(tauA_MPV))))
      error('Inverse dynamics (actuation coordinates) does not match with regressor form.')
    end
    
    %% Gravitationsvektor in Antriebskoordinaten
    taugA_vp2 = %RN%_gravload_para_qa_slag_vp2(xP, q, g, legFrame, ...
      koppelP, pkin, m, mrSges);
    taugA_reg = %RN%_gravload_para_qa_regmin(xP, q, g, legFrame, ...
      koppelP, pkin);
    taugA_MPV = taugA_reg*MPV;
    DeltagA = taugA_MPV - taugA_vp2;
    if any(abs(DeltagA) > 1e6*eps(1+max(abs(taugA_MPV))))
      error('Gravload (actuation coordinates) does not match with regressor form.')
    end
    
    %% Coriolisvektor in Antriebskoordinaten
    taucA_vp2 = %RN%_coriolisvec_para_qa_slag_vp2(xP, xPD, q, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    taucA_reg = %RN%_coriolisvec_para_qa_regmin(xP, xPD, q, legFrame, ...
      koppelP, pkin);
    taucA_MPV = taucA_reg*MPV;
    DeltacA = taucA_MPV - taucA_vp2;
    if any(abs(DeltacA) > 1e6*eps(1+max(abs(taucA_MPV))))
      error('Coriolis Vector (actuation coordinates) does not match with regressor form.')
    end
    
    %% Massenmatrix in Antriebskoordinaten
    MMA_vp2 = %RN%_inertia_para_qa_slag_vp2(xP, q, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    MMA_reg = %RN%_inertia_para_qa_regmin(xP, q, legFrame, ...
      koppelP, pkin);
    MMA_MPV_vec = MMA_reg*MPV;
    MMA_MPV = vec2mat(MMA_MPV_vec);
    DeltaMMA = MMA_MPV - MMA_vp2;
    if any(abs(DeltaMMA(:)) > 1e6*eps(1+max(abs(DeltaMMA(:)))))
      error('Inertia Matrix (actuation coordinates) does not match with regressor form.')
    end
  else % if N_XP > 4
    %% Gesamtdynamik
    tauA_MPV = (Jinv)' \ tauX_regmin;
    tauA_vp2 = (Jinv)' \ tauX_vp2;
    
    %% Gravitationsvektor
    taugA_MPV = (Jinv)' \ taugX_regmin;
    taugA_vp2 = (Jinv)' \ taugX_vp2;
    
    %% Coriolisvektor
    taucA_MPV = (Jinv)' \ taucX_regmin;
    taucA_vp2 = (Jinv)' \ taucX_vp2;
    
    %% Massenmatrix
    MMA_MPV = (Jinv)' \ MMX_MPV;
    MMA_vp2 = (Jinv)' \ MMX_vp2;
  end
end
fprintf('Tested regressor form vs inverse dynamic for %d random joint angles for %s\n', ...
  n, robot_name);
  
%% Teste Funktionsaufruf mit übergebenem Regressor gegen Regressormatrix
% Die direkte Übergabe des Dynamik-Parametervektors ist effizienter als die
% nachträgliche Multiplikation des Regressors
for i = 1:n
  q = [];
  for j = 1:Q_N
    q = [q;Q(1,(j-1)*NQJ+1:j*NQJ)]; %#ok<AGROW>
  end
  q = q';
  xP = XP(i,:)';
  xPD = XPD(i,:)';
  xPDD = XPDD(i,:)';
  g = G(i,:)';
  
  Jinv = %RN%_Jinv(xP, q, pkin, koppelP, ...
    legFrame);
  %% Dynamik in Plattform-Koordinaten
  tauX_regmin = %RN%_invdyn_para_pf_regmin(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin);
  tauX_MPV = tauX_regmin*MPV;
  tauX_func = %RN%_invdyn_para_pf_mdp(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin, MPV);
  DeltaX = tauX_MPV - tauX_func;
  if any(abs(DeltaX) > 1e6*eps(1+max(abs(tauX_MPV))))
    error('Inverse dynamics (platform coordinates) from parameter regressor does not match with pre-multiplied calculation.')
  end
  
  %% Gravitationsvektor in Plattform-Koordinaten
  taugX_regmin = %RN%_gravload_para_pf_regmin(xP, q, g, legFrame, ...
    koppelP, pkin);
  taugX_MPV = taugX_regmin*MPV;
  taugX_func = %RN%_gravload_para_pf_mdp(xP, q, g, legFrame, ...
    koppelP, pkin, MPV);
  DeltagX = taugX_MPV - taugX_func;
  if any(abs(DeltagX) > 1e6*eps(1+max(abs(taugX_MPV))))
    error('Grav Load (platform coordinates) from parameter regressor does not match with pre-multiplied calculation.')
  end
  
  %% Coriolisvektor in Plattform-Koordinaten
  taucX_regmin = %RN%_coriolisvec_para_pf_regmin(xP, xPD, q, legFrame, ...
    koppelP, pkin);
  taucX_MPV = taucX_regmin*MPV;
  taucX_func = %RN%_coriolisvec_para_pf_mdp(xP, xPD, q, legFrame, ...
    koppelP, pkin, MPV);
  DeltacX = taucX_MPV - taucX_func;
  if any(abs(DeltacX) > 1e6*eps(1+max(abs(taucX_MPV))))
    error('Coriolis-vector (platform coordinates) from parameter regressor does not match with pre-multiplied calculation.')
  end
  
  %% Massenmatrix in Plattform-Koordinaten
  MMX_vp2 = %RN%_inertia_para_pf_slag_vp2(xP, q, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  MMX_regmin = %RN%_inertia_para_pf_regmin(xP, q, legFrame, ...
    koppelP, pkin);
  MMX_MPV_vec = MMX_regmin*MPV;
  MMX_MPV = reshape(MMX_MPV_vec,N_XP,N_XP)';
  MMX_func = %RN%_inertia_para_pf_mdp(xP, q, legFrame, ...
    koppelP, pkin, MPV);
  DeltaMMX = MMX_MPV - MMX_func;
  if any(abs(DeltaMMX) > 1e6*eps(1+max(abs(MMX_MPV(:)))))
    error('Inertia matrix (platform coordinates) from parameter regressor does not match with pre-multiplied calculation.')
  end
  
  %% Dynamik in Antriebskoordinaten
  if N_XP <= 4 && ~isempty(fileparts(which('%RN%_invdyn_para_qa_slag_vp2')))
    % nur testen, falls Funktionen auch generiert wurden.
    tauA_reg = %RN%_invdyn_para_qa_regmin(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin);
    tauA_MPV = tauA_reg*MPV;
    tauA_func = %RN%_invdyn_para_qa_mdp(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin, MPV);
    DeltaA = tauA_MPV - tauA_func;
    if any(abs(DeltaA) > 1e6*eps(1+max(abs(tauA_MPV))))
      error('Inverse dynamics (actuation coordinates) from parameter regressor does not match with pre-multiplied calculation.')
    end
    
    %% Gravitationsvektor in Antriebskoordinaten
    taugA_reg = %RN%_gravload_para_qa_regmin(xP, q, g, legFrame, ...
      koppelP, pkin);
    taugA_MPV = taugA_reg*MPV;
    taugA_func = %RN%_gravload_para_qa_mdp(xP, q, g, legFrame, ...
      koppelP, pkin, MPV);
    DeltagA = taugA_MPV - taugA_func;
    if any(abs(DeltagA) > 1e6*eps(1+max(abs(taugA_MPV))))
      error('Grav Load (actuation coordinates) from parameter regressor does not match with pre-multiplied calculation.')
    end
    
    %% Coriolisvektor in Antriebskoordinaten
    taucA_reg = %RN%_coriolisvec_para_qa_regmin(xP, xPD, q, legFrame, ...
      koppelP, pkin);
    taucA_MPV = taucA_reg*MPV;
    taucA_func = %RN%_coriolisvec_para_qa_mdp(xP, xPD, q, legFrame, ...
      koppelP, pkin, MPV);
    DeltacA = taucA_MPV - taucA_func;
    if any(abs(DeltacA) > 1e6*eps(1+max(abs(taucA_MPV))))
      error('Coriolis-vector (actuation coordinates) from parameter regressor does not match with pre-multiplied calculation.')
    end
    
    %% Massenmatrix in Antriebskoordinaten
    MMA_reg = %RN%_inertia_para_qa_regmin(xP, q, legFrame, ...
      koppelP, pkin);
    MMA_MPV_vec = MMA_reg*MPV;
    MMA_MPV = vec2mat(MMA_MPV_vec);
    MMA_func = %RN%_inertia_para_qa_mdp(xP, q, legFrame, ...
      koppelP, pkin, MPV);
    DeltaMMA = MMA_MPV - MMA_func;
    if any(abs(DeltaA) > 1e6*eps(1+max(abs(tauA_MPV))))
      error('Inertia matrix (actuation coordinates) from parameter regressor does not match with pre-multiplied calculation.')
    end
  end
end
fprintf('Tested inverse dynamics functions with parameter vector input for %d random joint angles for %s\n', ...
  n, robot_name);

%% Prüfe Minimalparametervektor gegen Matrix mit Inertialparameterzuordnung
% [Sousa2014] Gl. (38)
[K, K_d, P_b, P_d] = %RN%_PV2_MPV_transformations_fixb(pkin);
MPV_test = K*PV2;
if length(MPV_test)~=length(MPV)
  error('Dimension der MPV-Zerlegung stimmt nicht: %d vs %d Einträge.', ...
    length(MPV_test), length(MPV));
end
test = MPV - MPV_test;
if any(abs(test(:)) > 1e-10)
  error('Minimalparametervektor stimmt nicht mit MPV aus Inertialparametermatrix überein');
end
% MPV-Transformationsmatrix aus Teilmatrizen aus [Sousa2014] aufbauen und testen
K_test = (P_b' + K_d*P_d'); % [Sousa2014] Gl. (39)
Test = abs(K-K_test);
if any(Test(:)>1e-12)
  error('Test [Sousa2014] Gl. (38) fehlgeschlagen!');
end
fprintf('Transformationen des fixb-Minimalparametervektors erfolgreich getestet\n');


%% Teste Minimalparameterform gegen numerische Berechnung nach [Gautier1990]
% Matrix mit Samples der Regressormatrix erstellen ([Gautier1990], Gl. (8))
% Zufällige Werte, nach [Gautier1990], Kap. 5-1-1
nreps = ceil(length(PV2)/n); % falls es viel mehr Parameter als n=100 sind
W_g_invdyn = NaN(NQJ*n*nreps, length(PV2)); % Informationsmatrix des Inertialparameter-Regressors. Zum Testen des Rangs
% W_g_energy = NaN(n*nreps, length(PV2)); % Gleiche Matrix, nur mit Energie, statt Dynamik
for k = 1:nreps
  for j = 1:n
    q = [];
    for ll = 1:Q_N
      q = [q;Q(1,(ll-1)*NQJ+1:ll*NQJ)]; %#ok<AGROW>
    end
    q = q';
    xP = XP(i,:)';
    xPD = XPD(i,:)';
    xPDD = XPDD(i,:)';
    g = G(j,:)';
    i = (k-1)*n+j; % Index für Informationsmatrix
    % [Gautier1990] Gl. (7)
    tauX_reg2 = %RN%_invdyn_para_pf_reg2(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin);
    % Füllen der Matrix: [Gautier1990], Kap. 2-3
    % [Gautier1990] Gl. (8) (Füllen mit Dynamik-Regressor)
    W_g_invdyn((i-1)*N_XP+1:i*N_XP,:) = tauX_reg2;
  end
end
% Struktur mit Eingabedaten für Algorithmus generieren
[Ksym, K_dsym, P1sym, P2sym] = %RN%_PV2_MPV_transformations_fixb(pkin);
plin_num_test_struct = struct('W', W_g_invdyn, 'PV2', PV2, 'MPV', MPV, ...
  'P1sym', P1sym, 'P2sym', P2sym, 'K_dsym', K_dsym, 'Ksym', Ksym, ...
  'NQ', NQJ, 'PV2_Names', {PV2_Names}, 'qr_tolerance', NaN);
fprintf('Untersuche Parameterreduzierung für Dynamik-Regressor\n');
try
  robot_paramlin_test_reg_num(plin_num_test_struct);
catch err
  if false % Parameter-Minimierung funktionert nicht immer
    throw(err);
  else
    % Werfe keinen Fehler auf. Da man bis hier gekommen ist, ist die
    % Parameterreduzierung auf jeden Fall richtig. Nur anscheinend numerisch
    % nicht minimal.
    warning('Es trat ein Fehler bei der Prüfung der Minimalität der Parameterreduktion auf (siehe vorherige Meldungen)');
  end
end

fprintf('Symbolisch berechnete Minimalparameterform gegen numerische Form geprüft\n');
