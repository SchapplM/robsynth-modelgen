% Teste parameterlineare Formen der Dynamik für parallele Roboter

% %VERSIONINFO%

% Tim Job (Studienarbeit bei Moritz Schappler), 2018-12
% Moritz Schappler, schappler@irt.uni-hannover.de
% (C) Institut für Mechatronische Systeme, Universität Hannover

clc
clear

NQJ = %NQJ_P%;
N_LEGS = %N_LEGS%; % number of legs
N_XP = %N_XP%; % number of platform DOF
robot_name = '%RN%';

%% Parameter
TSS = %RN%_varpar_testfunctions_parameter_par();
for f = fields(TSS)'
  eval(sprintf('%s=TSS.%s;',f{1},f{1}));
end

% Minimalparametervektor
MPV = %RN%_minimal_parameter_para(pkin, m, mrSges, Ifges, koppelP);

%% Test inverse dynamic vs regressor form
Q_GES = length(Q(1,:));
Q_N = Q_GES/NQJ;
for i = 1:n
  q = [];
  for j = 1:Q_N
    q = [q;Q(1,(j-1)*NQJ+1:j*NQJ)]; %#ok<AGROW>
  end
  q = q';
  xP = XP(i,:)';
  xPD = XPD(i,:)';
  xPDD = XPDD(i,:)';
  g = G(i,:)';
  
  Jinv = %RN%_Jinv(xP, q, pkin, koppelP, ...
    legFrame);
  %% Dynamik in Plattform-Koordinaten
  tauX_vp2 = %RN%_invdyn_para_pf_slag_vp2(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  tauX_reg = %RN%_invdyn_para_pf_reg(xP, xPD, xPDD, q, g, legFrame, ...
    koppelP, pkin);
  tauX_MPV = tauX_reg*MPV;
  DeltaX = tauX_MPV - tauX_vp2;
  if any(abs(DeltaX) > 1e6*eps(tauX_MPV))
    error('Inverse dynamics (platform coordinates) does not match with regressor form.')
  end
  
  %% Gravitationsvektor in Plattform-Koordinaten
  taugX_vp2 = %RN%_gravload_para_pf_slag_vp2(xP, q, g, legFrame, ...
    koppelP, pkin, m, mrSges);
  taugX_reg = %RN%_gravload_para_pf_reg(xP, q, g, legFrame, ...
    koppelP, pkin);
  taugX_MPV = taugX_reg*MPV;
  DeltagX = taugX_MPV - taugX_vp2;
  if any(abs(DeltagX) > 1e6*eps(taugX_MPV))
    error('Gravload (platform coordinates) does not match with regressor form.')
  end
  
  %% Coriolisvektor in Plattform-Koordinaten
  taucX_vp2 = %RN%_coriolisvec_para_pf_slag_vp2(xP, xPD, q, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  taucX_reg = %RN%_coriolisvec_para_pf_reg(xP, xPD, q, legFrame, ...
    koppelP, pkin);
  taucX_MPV = taucX_reg*MPV;
  DeltacX = taucX_MPV - taucX_vp2;
  if any(abs(DeltacX) > 1e6*eps(taucX_MPV))
    error('Coriolis Vector (platform coordinates) does not match with regressor form.')
  end
  
  %% Massenmatrix in Plattform-Koordinaten
  MMX_vp2 = %RN%_inertia_para_pf_slag_vp2(xP, q, legFrame, ...
    koppelP, pkin, m, mrSges, Ifges);
  MMX_reg = %RN%_inertia_para_pf_reg(xP, q, legFrame, ...
    koppelP, pkin);
  MMX_MPV_vec = MMX_reg*MPV;
  MMX_MPV = vec2symmat(MMX_MPV_vec);
  DeltaMMX = MMX_MPV - MMX_vp2;
  if any(abs(DeltaMMX) > 1e6*eps(MMX_MPV))
    error('Inertia Matrix (platform coordinates) does not match with regressor form.')
  end
  
  %% Dynamik in Antriebskoordinaten
  if N_XP <= 4 && ~isempty(fileparts(which('%RN%_invdyn_para_qa_slag_vp2')))
    % nur testen, falls Funktionen auch generiert wurden.
    tauA_vp2 = %RN%_invdyn_para_qa_slag_vp2(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    tauA_reg = %RN%_invdyn_para_qa_reg(xP, xPD, xPDD, q, g, legFrame, ...
      koppelP, pkin);
    tauA_MPV = tauA_reg*MPV;
    DeltaA = tauA_MPV - tauA_vp2;
    if any(abs(DeltaA) > 1e6*eps(tauA_MPV))
      error('Inverse dynamics (actuation coordinates) does not match with regressor form.')
    end
    
    %% Gravitationsvektor in Antriebskoordinaten
    taugA_vp2 = %RN%_gravload_para_qa_slag_vp2(xP, q, g, legFrame, ...
      koppelP, pkin, m, mrSges);
    taugA_reg = %RN%_gravload_para_qa_reg(xP, q, g, legFrame, ...
      koppelP, pkin);
    taugA_MPV = taugA_reg*MPV;
    DeltagA = taugA_MPV - taugA_vp2;
    if any(abs(DeltagA) > 1e6*eps(taugA_MPV))
      error('Gravload (actuation coordinates) does not match with regressor form.')
    end
    
    %% Coriolisvektor in Antriebskoordinaten
    taucA_vp2 = %RN%_coriolisvec_para_qa_slag_vp2(xP, xPD, q, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    taucA_reg = %RN%_coriolisvec_para_qa_reg(xP, xPD, q, legFrame, ...
      koppelP, pkin);
    taucA_MPV = taucA_reg*MPV;
    DeltacA = taucA_MPV - taucA_vp2;
    if any(abs(DeltacA) > 1e6*eps(taucA_MPV))
      error('Coriolis Vector (actuation coordinates) does not match with regressor form.')
    end
    
    %% Massenmatrix in Antriebskoordinaten
    MMA_vp2 = %RN%_inertia_para_qa_slag_vp2(xP, q, legFrame, ...
      koppelP, pkin, m, mrSges, Ifges);
    MMA_reg = %RN%_inertia_para_qa_reg(xP, q, legFrame, ...
      koppelP, pkin);
    MMA_MPV_vec = MMA_reg*MPV;
    MMA_MPV = vec2symmat(MMA_MPV_vec);
    DeltaMMA = MMA_MPV - MMA_vp2;
    if any(abs(DeltaA) > 1e6*eps(tauA_MPV))
      error('Inertia Matrix (actuation coordinates) does not match with regressor form.')
    end
  else % if N_XP > 4
    %% Gesamtdynamik
    tauA_MPV = (Jinv)' \ tauX_reg;
    tauA_vp2 = (Jinv)' \ tauX_vp2;
    
    %% Gravitationsvektor
    taugA_MPV = (Jinv)' \ taugX_reg;
    taugA_vp2 = (Jinv)' \ taugX_vp2;
    
    %% Coriolisvektor
    taucA_MPV = (Jinv)' \ taucX_reg;
    taucA_vp2 = (Jinv)' \ taucX_vp2;
    
    %% Massenmatrix
    MMA_MPV = (Jinv)' \ MMX_MPV;
    MMA_vp2 = (Jinv)' \ MMX_vp2;
  end
end
fprintf('Tested regressor form vs inverse dynamic for %d random joint angles for %s\n', ...
  n, robot_name);

