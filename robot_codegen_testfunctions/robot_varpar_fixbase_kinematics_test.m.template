% Test function for kinematics from symbolic calculations
% with fixed base model

% %VERSIONINFO%

clc
clear

NQJ = %NQJ%;
NJ = %NJ%;
NL = %NL%;
robot_name = '%RN%';

%% Parameter
TSS = %RN%_varpar_testfunctions_parameter();
for f = fields(TSS)'
  eval(sprintf('%s=TSS.%s;',f{1},f{1}));
end

%% Init

% Prüfe, ob kinematische Zwangsbedingungen vorliegen.
% Dann entfallen die Tests der numerischen Funktionen
if NJ ~= NQJ
  KINCONSTR = true;
  fprintf('Einige Tests entfallen aufgrund der Existenz kinematischer Zwangsbedingungen\n');
else
  KINCONSTR = false;  
end

if any(sigma)
  fprintf('Einige Tests entfallen aufgrund der Existenz von Schubgelenken\n');
end
%% Kinematik gegen Jacobi-Matrix testen (fixed base)

for i = 1:size(Q, 1)
  for j  = 1:NQJ % incremental change of joint angle j
    q = Q(i,:)';

    % differential kinematics from forward dynamics
    E = eye(NQJ);
    qDelta = 1e-10*E(:,j);
    Tc_1 = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, pkin);
    Tc_2 = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q+qDelta, pkin);
    xDelta_fkine = Tc_2(1:3,4,end) - Tc_1(1:3,4,end);

    % differential kinematics from Jacobian function
    JG = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(NJ+1), zeros(3,1), pkin);
    xDelta_jacob = JG*qDelta;

    x1_fkine = Tc_1(1:3,4,end);
    x2_fkine = Tc_2(1:3,4,end);
    x2_jacob = x1_fkine + xDelta_jacob(1:3);

    % calculate error
    Error_cart = x2_fkine(1:3) - x2_jacob(1:3);
    if any(abs(Error_cart) > 1e-10)
      error('Jacobian does not match with forward kinematics. Error = [%s]. Deltaq%d', ...
        disp_array(Error_cart', '%.5e'), j);
    end

  end
end
fprintf('Tested Jacobian (fixed base) against forward kinematics for %d random joint angles.\n', ...
	size(Q, 1));
 
%% Teste Jacobi-Matrix für unterschiedliche Punkte mit der Adjungierten
if ~KINCONSTR && ~any(sigma)
for i = 1:size(Q, 1)
  for j  = 1:NQJ+1 % Jacobi für jeden Körper
    q = Q(i,:)';
    Tc = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, pkin);
    
    r_j_Oj_P = rand(3,1); % zufälliger Punkt auf dem Körper
    
    % Jacobi zum Punkt aus direkter Berechnung
    JG_P = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(j), r_j_Oj_P, pkin);
    
    % Jacobi zum Koordinatenursprung des Körpers
    JG_Oj = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(j), zeros(3,1), pkin);
    
    % Jacobi zum Punkt berechnet mit Adjunkt-Matrix
    R_0_j = Tc(1:3,1:3,j);
    r_0_Oj_P = R_0_j*r_j_Oj_P;
    A_0_P_Oj = adjoint_jacobian(r_0_Oj_P);
    JG_P_test = A_0_P_Oj * JG_Oj;
    
    if any(abs(JG_P(:) - JG_P_test(:)) > 1e-10)
      error('Berechnung der Jacobi-Matrix mit Adjungierten stimmt nicht mit Funktion überein');
    end
  end
end
fprintf('Tested Jacobian direct vs adjoint calculation for fixed base.\n');
end
%% Teste Jacobi-Matrix-Zeitableitung für unterschiedliche Punkte mit der Adjungierten
if ~KINCONSTR && ~any(sigma)
for i = 1:size(Q, 1)
  for j  = 1:NQJ+1 % Jacobi für jeden Körper
    q = Q(i,:)';
    qD = QD(i,:)';
    
    Tc = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, pkin);
    
    r_j_Oj_P = rand(3,1); % zufälliger Punkt auf dem Körper
    
    % Jacobi- und Zeitableitung zum Punkt aus direkter Berechnung
    JG_P = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(j), r_j_Oj_P, pkin);
    JGD_P = %RN%_jacobigD_floatb_twist_sym_varpar(q, qD, uint8(j), r_j_Oj_P, pkin);

    % Jacobi und -Zeitableitung zum Koordinatenursprung des Körpers
    JG_Oj = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(j), zeros(3,1), pkin);
    JGD_Oj = %RN%_jacobigD_floatb_twist_sym_varpar(q, qD, uint8(j), zeros(3,1), pkin);

    % Jacobi-Zeitableitung zum Punkt berechnet mit Adjunkt-Matrix
    R_0_j = Tc(1:3,1:3,j);
    r_0_Oj_P = R_0_j*r_j_Oj_P;
    A_0_P_Oj = adjoint_jacobian(r_0_Oj_P);

    V_0_i = JG_Oj*qD;
    omega_0_i = V_0_i(4:6);

    AD_0_P_Oj = adjointD_jacobian(r_j_Oj_P, R_0_j, omega_0_i);

    JGD_P_test = AD_0_P_Oj * JG_Oj + A_0_P_Oj * JGD_Oj;

    if any(abs(JGD_P(:) - JGD_P_test(:)) > 1e-10)
      error('Berechnung der Jacobi-Matrix-Zeitableitung mit Adjungierten stimmt nicht mit Funktion überein');
    end
  end
end
fprintf('Tested Jacobian time derivate from direct vs adjoint calculation for fixed base.\n');
end
%% Test Time Derivate of Jacobian
if ~KINCONSTR && ~any(sigma)
matlabfcn2mex({'%RN%_jacobig_mdh_num', '%RN%_jacobigD_mdh_num'});
for kk = 1:NJ % Test for linear joint trajectory
  n = 1e5; % little steps -> small error
  Q_traj = zeros(n,NJ);
  q_kk_start = -pi/2;
  q_kk_end = pi/2;
  Q_traj(:,kk) = linspace(q_kk_start, q_kk_end, n);
  QD_traj = zeros(n,NJ);
  T = 1;
  QD_traj(:,kk) = (q_kk_end-q_kk_start)/T; % linear velocity profile
  dT = T/n;
  JG = zeros(6,NJ);

  t1 = tic;
  for i = 1:n % Test Difference for each trajectory point
    JG_vorher = JG;
    q = Q_traj(i,:)';
    qD = QD_traj(i,:)';     
    % calculate jacobian time derivate with two methods
    JG = %RN%_jacobig_mdh_num_mex(q, uint8(NJ+1), zeros(3,1), pkin, v);
    JGD_num1 = (JG - JG_vorher) / dT;
    JGD_num2 =  %RN%_jacobigD_mdh_num_mex(q, qD, uint8(NJ+1), zeros(3,1), pkin, v);

    % calculate error
    if i > 2
      JGD_Diff = JGD_num1 - JGD_num2;
      I = abs(JGD_Diff) > 1e-3;
      if any(I(:))
        disp('from numeric differentiation:');
        disp(JGD_num1);
        disp('from direct formula:');
        disp(JGD_num2);          
        error('Zeitableitungen der Jacobi-Matrizen weichen voneinander ab!');
      end
    end

  end
  fprintf('Erfolgreiche Übereinstimmung von JGD für Trajektorie aus %d Gelenkwinkeln für Achse %d. Rechenzeit: %1.0fs\n', ...
    n, kk, toc(t1));
end
fprintf('Tested Jacobian Time derivative for fixed base.\n');
end

%% Symbolische gegen numerische (geometrische) Jacobi-Matrix testen
if ~KINCONSTR && ~any(sigma)
for iq = 1:size(Q, 1) % Über Zufallsposen
  for jb  = 1:NL % Über alle Körper
    r_i_i_C = rand(3,1);
    q = Q(iq,:)';
    qD = QD(iq,:)';
    Jg_num = %RN%_jacobig_mdh_num(q, uint8(jb), r_i_i_C, pkin, v);
    Jg_sym = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(jb), r_i_i_C, pkin);
    
    Jg_Delta = Jg_num - Jg_sym;
    if any(abs (Jg_Delta(:)) > 1e-10) || any(isnan(Jg_Delta(:)))
      error('iq=%d, jb=%d: Symbolische und numerische Jacobi-Matrizen stimmen nicht', iq, jb);
    end
    
    JgD_num = %RN%_jacobigD_mdh_num(q, qD, uint8(jb), r_i_i_C, pkin, v);
    JgD_sym = %RN%_jacobigD_floatb_twist_sym_varpar(q, qD, uint8(jb), r_i_i_C, pkin);
    JgD_Delta = JgD_num - JgD_sym;
    if any( abs (JgD_Delta(:)) > 1e9*eps(1+max(abs(JgD_sym(:)))) ) || any(isnan(JgD_Delta(:)))
      error('Symbolische und numerische Jacobi-Matrix-Zeitableitungen stimmen nicht');
    end
  end
end
fprintf('Erfolgreich symbolische gegen numerische (geometrische) Jacobi-Matrix getestet (und Zeitableitung).\n');
end

%% Analytische gegen Geometrische Jacobi-Matrix testen
for iq = 1:size(Q, 1) % Über Zufallsposen
  for jb  = 1:NL % Über alle Körper
    q = Q(iq,:)';
    qD = Q(iq,:)';    
    Jg_rot = %RN%_jacobig_rot_floatb_twist_sym_varpar(q, uint8(jb), pkin);
    Ja_rot = %RN%_jacobia_rot_floatb_twist_sym_varpar(q, uint8(jb), pkin);
    
    % direkte Kinematik (mit gleichem Modell berechnet. Gleichheit der
    % Modelle wird in anderer Testfunktion  verifiziert)
    Tc_mdh = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, pkin);
    T_jb = Tc_mdh(:,:,jb);

    % Winkelkonvention und Umrechnungsfaktor
    rpy = r2rpy(t2r(T_jb));
    J_rpy = angvelotrans_rpy(rpy);

    % Umrechnung der analytischen in die geometrische Jacobi-Matrix
    % [1], S. 52, Gl. (4.25)
    Jg_rot_test = J_rpy * Ja_rot;

    % Vergleiche die auf zwei Wegen berechnete geometrische Jacobi-Matrix
    Diff = Jg_rot_test - Jg_rot;
    if any(abs(Diff(:)) > 1e-10)
      error('Geometrische und Analytische Jacobi-Matrizen stimmen nicht überein (Körper %d)', jb);
    end
    
    % Berechne Zeitableitung der analytischen und geometrischen
    % Jacobi-Matrix
    JgD_rot = %RN%_jacobigD_rot_floatb_twist_sym_varpar(q, qD, uint8(jb), pkin);
    JaD_rot = %RN%_jacobiaD_rot_floatb_twist_sym_varpar(q, qD, uint8(jb), pkin);
    % Aus Produktregel der Zeitableitung von [1], S. 52, Gl. (4.25)
    rpyD = Ja_rot*qD;
    JD_rpy = angvelotrans_rpyD(rpy, rpyD);
    JgD_rot_test = JD_rpy * Ja_rot + J_rpy * JaD_rot;
    % Vergleiche die auf zwei Wegen berechnete Zeitableitung der geometrischen Jacobi-Matrix
    DiffD = JgD_rot_test - JgD_rot;
    if any( abs(DiffD(:)) > 1e9*eps(1+max(abs(JgD_rot(:)))) )
      error('Zeitableitung der geometrischen und analytischen Jacobi-Matrizen stimmen nicht überein (Körper %d)', jb);
    end
  end
end
fprintf('Erfolgreich analytische gegen geometrische Jacobi-Matrix (Rotationsteil) getestet (und Zeitableitung).\n');

%% Kompiliere alle Jacobi-bezogenen Funktionen
matlabfcn2mex({ '%RN%_jacobigD_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobiaD_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobigD_floatb_twist_sym_varpar', ...
                '%RN%_jacobiaD_floatb_twist_sym_varpar', ...
                '%RN%_jacobig_floatb_twist_sym_varpar', ...
                '%RN%_jacobia_floatb_twist_sym_varpar', ...
                '%RN%_jacobig_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobia_rot_floatb_twist_sym_varpar'});
        


