% Test function for kinematics from symbolic calculations
% with floating base model

% %VERSIONINFO%

clc
clear

NQJ = %NQJ%;
NJ = %NJ%;
NL = %NL%;
robot_name = '%RN%';

testfunctions_path_init

%% Parameter
%RN%_varpar_testfunctions_parameter


%% Kinematik gegen Jacobi-Matrix testen (fixed base)

for i = 1:size(Q, 1)
  for j  = 1:NQJ % incremental change of joint angle j
    q = Q(i,:)';

    % differential kinematics from forward dynamics
    E = eye(NQJ);
    qDelta = 1e-10*E(:,j);
    Tc_1 = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    Tc_2 = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q+qDelta, ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    xDelta_fkine = Tc_2(1:3,4,end) - Tc_1(1:3,4,end);

    % differential kinematics from Jacobian function
    JG = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(NJ+1), zeros(3,1), ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    xDelta_jacob = JG*qDelta;

    x1_fkine = Tc_1(1:3,4,end);
    x2_fkine = Tc_2(1:3,4,end);
    x2_jacob = x1_fkine + xDelta_jacob(1:3);

    % calculate error
    Error_cart = x2_fkine(1:3) - x2_jacob(1:3);
    if any(abs(Error_cart) > 1e-10)
      error('Jacobian does not match with forward kinematics. Error = [%s]. Deltaq%d', ...
        dispparam(Error_cart', '%.5e'), j);
    end

  end
end
fprintf('Tested Jacobian (fixed base) against forward kinematics for %d random joint angles.\n', ...
	size(Q, 1));
 

%% Test Time Derivate of Jacobian
Mex_Erstellen({'%RN%_jacobig_mdh_num', '%RN%_jacobigD_mdh_num'});
for kk = 1:NJ % Test for linear joint trajectory
  n = 1e5; % little steps -> small error
  Q_traj = zeros(n,NJ);
  q_kk_start = -pi/2;
  q_kk_end = pi/2;
  Q_traj(:,kk) = linspace(q_kk_start, q_kk_end, n);
  QD_traj = zeros(n,NJ);
  T = 1;
  QD_traj(:,kk) = (q_kk_end-q_kk_start)/T; % linear velocity profile
  dT = T/n;
  JG = zeros(6,NJ);

  t1 = tic;
  for i = 1:n % Test Difference for each trajectory point
    JG_vorher = JG;
    q = Q_traj(i,:)';
    qD = QD_traj(i,:)';     
    % calculate jacobian time derivate with two methods
    JG = %RN%_jacobig_mdh_num_mex(q, uint8(NJ+1), zeros(3,1), ...
      alpha, a, d, q_offset, b, beta, v);
    JGD_num1 = (JG - JG_vorher) / dT;
    JGD_num2 =  %RN%_jacobigD_mdh_num_mex(q, qD, uint8(NJ+1), zeros(3,1), ...
      alpha, a, d, q_offset, b, beta, v);

    % calculate error
    if i > 2
      JGD_Diff = JGD_num1 - JGD_num2;
      I = abs(JGD_Diff) > 1e-3;
      if any(I(:))
        disp('from numeric differentiation:');
        disp(JGD_num1);
        disp('from direct formula:');
        disp(JGD_num2);          
        error('Zeitableitungen der Jacobi-Matrizen weichen voneinander ab!');
      end
    end

  end
  fprintf('Erfolgreiche Übereinstimmung von JGD für Trajektorie aus %d Gelenkwinkeln für Achse %d. Rechenzeit: %1.0fs\n', ...
    n, kk, toc(t1));
end
fprintf('Tested Jacobian Time derivative for fixed base.\n');

%% Symbolische gegen numerische (geometrische) Jacobi-Matrix testen
for iq = 1:size(Q, 1) % Über Zufallsposen
  for jb  = 1:NL % Über alle Körper
    r_i_i_C = rand(3,1);
    q = Q(iq,:)';
    qD = QD(iq,:)';
    % TODO: Übergabe der Kinematikparameter bei kinem. Zwangsbedingungen
    Jg_num = %RN%_jacobig_mdh_num(q, uint8(jb), r_i_i_C, ...
      alpha, a, d, q_offset, b, beta, v);
    Jg_sym = %RN%_jacobig_floatb_twist_sym_varpar(q, uint8(jb), r_i_i_C, ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    
    Jg_Delta = Jg_num - Jg_sym;
    if any(abs (Jg_Delta(:)) > 1e-10) || any(isnan(Jg_Delta(:)))
      error('Symbolische und numerische Jacobi-Matrizen stimmen nicht');
    end
    
    JgD_num = %RN%_jacobigD_mdh_num(q, qD, uint8(jb), r_i_i_C, ...
      alpha, a, d, q_offset, b, beta, v);
    JgD_sym = %RN%_jacobigD_floatb_twist_sym_varpar(q, qD, uint8(jb), r_i_i_C, ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    JgD_Delta = JgD_num - JgD_sym;
    if any(abs (JgD_Delta(:)) > 1e-10) || any(isnan(JgD_Delta(:)))
      error('Symbolische und numerische Jacobi-Matrix-Zeitableitungen stimmen nicht');
    end
  end
end
fprintf('Erfolgreich symbolische gegen numerische (geometrische) Jacobi-Matrix getestet (und Zeitableitung).\n');


%% Analytische gegen Geometrische Jacobi-Matrix testen
for iq = 1:size(Q, 1) % Über Zufallsposen
  for jb  = 1:NL % Über alle Körper
    q = Q(iq,:)';
    qD = Q(iq,:)';    
    Jg_rot = %RN%_jacobig_rot_floatb_twist_sym_varpar(q, uint8(jb), ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    Ja_rot = %RN%_jacobia_rot_floatb_twist_sym_varpar(q, uint8(jb), ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    
    % direkte Kinematik (mit gleichem Modell berechnet. Gleichheit der
    % Modelle wird in anderer Testfunktion  verifiziert)
    Tc_mdh = %RN%_fkine_fixb_rotmat_mdh_sym_varpar(q, ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    T_jb = Tc_mdh(:,:,jb);

    % Winkelkonvention und Umrechnungsfaktor
    rpy = r2rpy(t2r(T_jb))';
    J_rpy = rpy2jac(rpy(1), rpy(2), rpy(3));

    % Umrechnung der analytischen in die geometrische Jacobi-Matrix
    % [1], S. 52, Gl. (4.25)
    Jg_rot_test = J_rpy * Ja_rot;

    % Vergleiche die auf zwei Wegen berechnete geometrische Jacobi-Matrix
    Diff = Jg_rot_test - Jg_rot;
    if any(abs(Diff(:)) > 1e-10)
      error('Geometrische und Analytische Jacobi-Matrizen stimmen nicht überein (Körper %d)', jb);
    end
    
    % Berechne Zeitableitung der analytischen und geometrischen
    % Jacobi-Matrix
    JgD_rot = %RN%_jacobigD_rot_floatb_twist_sym_varpar(q, qD, uint8(jb), ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    JaD_rot = %RN%_jacobiaD_rot_floatb_twist_sym_varpar(q, qD, uint8(jb), ...
      alpha, a, d, q_offset, b, beta%KCPARG%);
    % Aus Produktregel der Zeitableitung von [1], S. 52, Gl. (4.25)
    rpyD = Ja_rot*qD;
    JD_rpy = angvelotrans_rpyD(rpy, rpyD);
    JgD_rot_test = JD_rpy * Ja_rot + J_rpy * JaD_rot;
    % Vergleiche die auf zwei Wegen berechnete Zeitableitung der geometrischen Jacobi-Matrix
    DiffD = JgD_rot_test - JgD_rot;
    if any(abs(DiffD(:)) > 1e-10)
      error('Zeitableitung der geometrischen und analytischen Jacobi-Matrizen stimmen nicht überein (Körper %d)', jb);
    end
  end
end
fprintf('Erfolgreich analytische gegen geometrische Jacobi-Matrix (Rotationsteil) getestet (und Zeitableitung).\n');

%% Kompiliere alle Jacobi-bezogenen Funktionen
Mex_Erstellen({ '%RN%_jacobigD_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobiaD_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobigD_floatb_twist_sym_varpar', ...
                '%RN%_jacobiaD_floatb_twist_sym_varpar', ...
                '%RN%_jacobig_floatb_twist_sym_varpar', ...
                '%RN%_jacobia_floatb_twist_sym_varpar', ...
                '%RN%_jacobig_rot_floatb_twist_sym_varpar', ...
                '%RN%_jacobia_rot_floatb_twist_sym_varpar'});
        
