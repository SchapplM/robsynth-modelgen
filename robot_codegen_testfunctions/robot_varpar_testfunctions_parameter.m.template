%% Allgemeine Definitionen
NQJ = %NQJ%;
NJ = %NJ%;
NL = %NL%;
robot_name = '%RN%';

%% Parameter definieren
a = rand(NJ,1);
alpha = zeros(NJ,1);
d = rand(NJ,1);
q_offset = zeros(NJ,1);
b = zeros(NJ,1);
beta = zeros(NJ,1);

rSges = rand(NL,3);
m = rand(NL,1);
Icges = [rand(NL,3), -rand(NL,3)*0.01];

[mrSges, Ifges] = ...
  inertial_parameters_convert_par1_par2(rSges, Icges, m);

%% Parameter prüfen
if any(m) < 0
  error('Massen sollten positiv sein');
end
for i = 2:NL
  Ic_i = inertiavector2matrix(Icges(i,:));
  if any(eig(Ic_i) < 0) 
    error('Trägheitstensor sollte positiv definit sein');
  end
end

%% Zufällige Roboterkonfigurationen

n = 100;
% Gelenkwinkel und -zeitableitungen
%REPLACE_QDEF%
Q = repmat(q_min',n,1) + rand(n,NQJ).*repmat(q_max'-q_min',n,1);
QD = (0.5-rand(n, NQJ))*pi;
QD(1:NQJ,:)=eye(NQJ);
QDD = (0.5-rand(n, NQJ))*pi;

% Gravitation
G = (0.5-rand(n, 3))*10;

% Basisposition
RB = (0.5-rand(n, 3))*10;

% Basisorientierung
% Zufällige Zeitableitung der Orientierungsdarstellung und ihrer
% Ableitungen
OB = (0.5-rand(n, 3))*pi;
OB(1,:) = 0;
OBD = (0.5-rand(n, 3))*pi;
OBDD = (0.5-rand(n, 3))*pi;

% Winkelgeschwindigkeit und Beschleunigung aus der Orientierungsdarstellung
% berechnen
VB = NaN(n,6);
AB = NaN(n,6);
VB(:,1:3) = (0.5-rand(n, 3))*10;
AB(:,1:3) = (0.5-rand(n, 3))*10;
for i = 1:n
  % Darstellung umwandeln.
  % TODO: Mit Transformationsmatrizen
  VB(i, 4:6) = rpyD2omega(OB(i,:), OBD(i,:));
  AB(i, 4:6) = rpyDD2omegaD(OB(i,:), OBD(i,:), OBDD(i,:));
  
  % Probe:
  T_basevel = rpy2jac(OB(i,1), OB(i,2), OB(i,3));
  obd_test = T_basevel \ VB(i, 4:6)';
  
  if any(abs(obd_test-OBD(i,:)') > 1e-10)
    error('Orientierung und Basisgeschwindigkeit stimmen nicht überein');
  end
end
