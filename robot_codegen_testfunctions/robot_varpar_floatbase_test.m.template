% Test function for inverse dynamics from symbolic calculations
% with floating base model

% Moritz Schappler, schappler@irt.uni-hannover.de, 2016-03
% (c) Institut für Regelungstechnik, Universität Hannover

clc
clear

NJ = %NJ%;
robot_name = '%RN%';

testfunctions_path_init

%% Parameter
%RN%_varpar_testfunctions_parameter

%% Alle Funktionen mit unterschiedlicher Basis-Orientierung berechnen
for i = 1:n
  ob = OB(i,:)';
  q = Q(i,:)';
  qD = QD(i,:)';
  
  r_W_W_0 = RB(i,:)';
  V_W_W_0 = VB(i,:)' .* [1;1;1;0;0;0];
  aB = AB(i,:)';
  xB_RPY = [r_W_W_0; ob];
  % Winkelgeschwindigkeit in RPY-Winkel-Zeitableitung umwandeln
  T_basevel = rpy2jac(ob(1), ob(2), ob(3));
  oDb = T_basevel \ V_W_W_0(4:6);
  xDB = [V_W_W_0(1:3); oDb];
  
  % Gravitationsvektor ins Basis-KS drehen
  g_world = G(i,:)';
  R_W_0 = rpy2r(ob(1), ob(2), ob(3));
  g_base = (R_W_0')*g_world;
  
  % Basis-Position und -Geschwindigkeit ins Basis-KS drehen (wird für
  % twist-Funktionen benötigt).
  r_0_W_0 = R_W_0' * r_W_W_0;
  V_0_W_0 = rotate_wrench(V_W_W_0, R_W_0');
  
  % Prüfe potentielle Energie
  U_eulxyz = %RN%_energypot_floatb_eulangrpy_sym_lag_varpar_par1(q, r_W_W_0, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  U_twist = %RN%_energypot_floatb_twist_sym_lag_varpar_par1(q, r_0_W_0, g_base, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  if abs(U_eulxyz - U_twist) > 1e-10
    error('Potentielle Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein');
  end

  % Prüfe kinetische Energie
  T_eulxyz = %RN%_energykin_floatb_eulangrpy_sym_lag_varpar_par1(q, qD, r_W_W_0, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  T_twist = %RN%_energykin_floatb_twist_sym_lag_varpar_par1(q, qD, V_0_W_0, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  if abs(T_eulxyz - T_twist) > 1e-10
    error('Kinetische Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein');
  end
end
fprintf('Tested functions with different floating base expressions for %d random joint angles for %s\n', ...
  n,robot_name);

%% Test coriolis vector and matrix without base velocity
for i = 1:n
  ob = OB(i,:);
  q = Q(i,:)';
  qD = QD(i,:)';
  % calculate coriolis vector directly from optimized function with
  % base velocity set to zero
  cq_fixb = %RN%_coriolisvec_joint_fixb_sym_lag_varpar_par1(q, qD, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  cq_floatb = %RN%_coriolisvec_joint_floatb_sym_lag_varpar_par1(q, qD, zeros(6,1), ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  if any(abs(cq_fixb - cq_floatb) > 1e-12)
    error('coriolis vector from floating base does not match with fixed base.');
  end
  
  % calculate coriolis vector directly from optimized function with
  % base velocity set to zero
  Cq_fixb = %RN%_coriolismat_joint_fixb_sym_lag_varpar_par1(q, qD, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Cq_floatb = %RN%_coriolismat_joint_floatb_sym_lag_varpar_par1(q, qD, zeros(6,1), ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Delta = Cq_fixb - Cq_floatb(:,7:end);
  if any(abs(Delta(:)) > 1e-12)
    error('coriolis matrix from floating base does not match with fixed base.');
  end
end
fprintf('Tested coriolis vector and matrix floating and fixed base for %d random joint angles for %s\n', ...
  n,robot_name);

%% Vergleich der Basis-Beschleunigung mit der Gravitation
for i = 1:n
  ob = OB(i,:)';
  q = Q(i,:)';
  qD = QD(i,:)';
  g_world = G(i,:)';
  R_W_0 = rpy2r(ob(1), ob(2), ob(3));
  g_base = (R_W_0')*g_world;
  % Drehmoment aus Gravitation im Vergleich mit Drehmoment aus
  % Basis-Beschleunigung
  Mqb = %RN%_inertia_joint_base_sym_lag_varpar_par1(q, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tau_acc_floatb = (Mqb*[-g_base; zeros(3,1);]);
  tau_acc_grav = %RN%_gravload_joint_sym_lag_varpar_par1(q, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  if any(abs(tau_acc_floatb - tau_acc_grav) > 1e-12)
    error('acceleration torque floating base and gravload do not match. %1.5e');
  end
end
fprintf('Tested acceleration torque based on floating base inertia and gravload for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Alle Funktionen mit Parametersatz 2 testen
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';
  qDD = QDD(i,:)';
  g_world = G(i,:)';
  V_W_W_0 = VB(i,:)';
  aB = AB(i,:)';
  % Coriolis
  tauc_par1 = %RN%_coriolisvec_joint_floatb_sym_lag_varpar_par1(q, qD, V_W_W_0,...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tauc_par2 = %RN%_coriolisvec_joint_floatb_sym_lag_varpar_par2(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tauc_par1-tauc_par2) > 1e-12)
    error('coriolis vectors do not match between par1/par2.');
  end
  Cq_par1 = %RN%_coriolismat_joint_floatb_sym_lag_varpar_par1(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Cq_par2 = %RN%_coriolismat_joint_floatb_sym_lag_varpar_par2(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges); 
  if any(abs(Cq_par1(:)-Cq_par2(:)) > 1e-12)
    error('coriolis matrices do not match between par1/par2.');
  end 
  % Inverse Dynamics
  tau_par1 = %RN%_invdyn_joint_floatb_sym_lag_varpar_par1(q, qD, qDD, V_W_W_0, aB, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tau_par2 = %RN%_invdyn_joint_floatb_sym_lag_varpar_par2(q, qD, qDD, V_W_W_0, aB, g_world, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tau_par1-tau_par2) > 1e-12)
    error('inverse dynamics joint torque vectors do not match between par1/par2.');
  end
end
fprintf('Tested Functions with parameter sets 1 and 2 for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);
