% Test function for inverse dynamics from symbolic calculations
% with floating base model

% Moritz Schappler, schappler@irt.uni-hannover.de, 2016-03
% (c) Institut für Regelungstechnik, Universität Hannover

clc
clear

NJ = %NJ%;
robot_name = '%RN%';

testfunctions_path_init

%% Parameter
%RN%_varpar_testfunctions_parameter

%% Alle Funktionen mit unterschiedlicher Basis-Orientierung berechnen
for i = 1:n
  ob = OB(i,:)';
  q = Q(i,:)';
  qD = QD(i,:)';
  qDD = QDD(i,:)';
  
  r_W_W_0 = RB(i,:)';
  V_W_W_0 = VB(i,:)';
  A_W_W_0 = AB(i,:)';
  
  % Winkelgeschwindigkeit in RPY-Winkel-Zeitableitung umwandeln
  % T_basevel = rpy2jac(ob(1), ob(2), ob(3)); % wird nicht benötigt
  oDb = OBD(i,:)';
  oDDb = OBDD(i,:)';
  xDB = [V_W_W_0(1:3); oDb];
  xDDB = [A_W_W_0(1:3); oDDb];
  
  % Gravitationsvektor ins Basis-KS drehen
  g_world = G(i,:)';
  R_W_0 = rpy2r(ob(1), ob(2), ob(3));
  g_base = (R_W_0')*g_world;
  
  % Basis-Position und -Geschwindigkeit ins Basis-KS drehen (wird für
  % twist-Funktionen benötigt).
  r_0_W_0 = R_W_0' * r_W_W_0;
  V_0_W_0 = rotate_wrench(V_W_W_0, R_W_0');
  A_0_W_0 = rotate_wrench(A_W_W_0, R_W_0');
   
  % Prüfe potentielle Energie
  U_eulxyz = %RN%_energypot_floatb_eulangrpy_slag_vp1(q, r_W_W_0, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  U_twist = %RN%_energypot_floatb_twist_slag_vp1(q, r_0_W_0, g_base, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  if abs(U_eulxyz - U_twist) > 1e-10
    error('Potentielle Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
  
  U_eulxyz = %RN%_energypot_floatb_eulangrpy_slag_vp2(q, r_W_W_0, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, mrSges);
  U_twist = %RN%_energypot_floatb_twist_slag_vp2(q, r_0_W_0, g_base, ...
    alpha, a, d, q_offset, b, beta, m, mrSges);
  if abs(U_eulxyz - U_twist) > 1e-10
    error('Potentielle Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par2)');
  end

  % Prüfe kinetische Energie
  T_eulxyz = %RN%_energykin_floatb_eulangrpy_slag_vp1(q, qD, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  T_twist = %RN%_energykin_floatb_twist_slag_vp1(q, qD, V_0_W_0, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  if abs(T_eulxyz - T_twist) > 1e-10
    error('Kinetische Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
  
  T_eulxyz = %RN%_energykin_floatb_eulangrpy_slag_vp2(q, qD, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  T_twist = %RN%_energykin_floatb_twist_slag_vp2(q, qD, V_0_W_0, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if abs(T_eulxyz - T_twist) > 1e-10
    error('Kinetische Energie mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par2)');
  end

  % Prüfe Gravitationsmoment
  taug_eulxyz = %RN%_gravload_joint_floatb_eulangrpy_slag_vp1(q, ob, g_world,...
    alpha, a, d, q_offset, b, beta, m, rSges);
  taug_twist = %RN%_gravload_joint_floatb_twist_slag_vp1(q, g_base, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  if any(abs(taug_eulxyz - taug_twist) > 1e-10)
    error('Gravitationsmoment mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
  taug_eulxyz = %RN%_gravload_joint_floatb_eulangrpy_slag_vp2(q, ob, g_world,...
    alpha, a, d, q_offset, b, beta, m, mrSges);
  taug_twist = %RN%_gravload_joint_floatb_twist_slag_vp2(q, g_base, ...
    alpha, a, d, q_offset, b, beta, m, mrSges);
  if any(abs(taug_eulxyz - taug_twist) > 1e-10)
    error('Gravitationsmoment mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par2)');
  end
  
  
  continue
  qD=qD*0
%   V_0_W_0(1:3) = 0;
%   xDB(1:3) = 0;
%   
%   V_0_W_0(4:6) = 0;
%   xDB(4:6) = 0;
  % Prüfe Coriolismoment
  % --> Prüfung der Basiskräfte ergibt keinen Sinn, da das Coriolismoment dort bei
  % Basisdarstellung "twist" falsch ist
  tauc_eulxyz = %RN%_coriolisvec_joint_floatb_eulangrpy_slag_vp1(q, qD, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m.*[NaN;0;1], rSges*0, Icges*0);
  tauc_twist = %RN%_coriolisvec_joint_floatb_twist_slag_vp1(q, qD, V_0_W_0,...
    alpha, a, d, q_offset, b, beta, m.*[NaN;0;1], rSges*0, Icges*0);
  if any(abs(tauc_eulxyz-tauc_twist) > 1e-12)
    error('Coriolismoment mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
  tauc_eulxyz = %RN%_coriolisvec_joint_floatb_eulangrpy_slag_vp2(q, qD, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  tauc_twist = %RN%_coriolisvec_joint_floatb_twist_slag_vp2(q, qD, V_0_W_0,...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tauc_eulxyz-tauc_twist) > 1e-12)
    error('Coriolismoment mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par2)');
  end
  
  % Prüfe Coriolismatrix
  
  % Prüfe Massenmatrix
  MM_eulxyz = %RN%_inertia_floatb_eulangrpy_slag_vp1(q, ob, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  MM_twist = %RN%_inertia_floatb_twist_slag_vp1(q, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  taua_eulxyz = MM_eulxyz*[xDDB; qDD];
  taua_twist = MM_twist*[A_0_W_0; qDD];
  if any(abs(taua_eulxyz-taua_twist) > 1e-12)
    error('Trägheitsmoment aus Massenmatrix mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
  MM_eulxyz = %RN%_inertia_floatb_eulangrpy_slag_vp2(q, ob, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  MM_twist = %RN%_inertia_floatb_twist_slag_vp2(q, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  taua_eulxyz = MM_eulxyz*[xDDB; qDD];
  taua_twist = MM_twist*[A_0_W_0; qDD];
  if any(abs(taua_eulxyz-taua_twist) > 1e-12)
    error('Trägheitsmoment aus Massenmatrix mit XYZ-Euler-Winkeln stimmt nicht mit normaler Form überein (par1)');
  end
   
  % Prüfe inverse Dynamik
end
fprintf('Tested functions with different floating base expressions for %d random joint angles for %s\n', ...
  n,robot_name);

%% Test coriolis vector and matrix without base velocity
for i = 1:n
  ob = OB(i,:);
  q = Q(i,:)';
  qD = QD(i,:)';
  % calculate coriolis vector directly from optimized function with
  % base velocity set to zero
  cq_fixb = %RN%_coriolisvec_joint_fixb_slag_vp1(q, qD, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  cq_floatb = %RN%_coriolisvec_joint_floatb_twist_slag_vp1(q, qD, zeros(6,1), ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  if any(abs(cq_fixb - cq_floatb) > 1e-12)
    error('coriolis vector from floating base does not match with fixed base.');
  end
  
  % calculate coriolis vector directly from optimized function with
  % base velocity set to zero
  Cq_fixb = %RN%_coriolismat_joint_fixb_slag_vp1(q, qD, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Cq_floatb = %RN%_coriolismat_joint_floatb_twist_slag_vp1(q, qD, zeros(6,1), ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Delta = Cq_fixb - Cq_floatb(:,7:end);
  if any(abs(Delta(:)) > 1e-12)
    error('coriolis matrix from floating base does not match with fixed base.');
  end
end
fprintf('Tested coriolis vector and matrix floating and fixed base for %d random joint angles for %s\n', ...
  n,robot_name);

%% Vergleich der Basis-Beschleunigung mit der Gravitation
for i = 1:n
  ob = OB(i,:)';
  q = Q(i,:)';
  qD = QD(i,:)';
  g_world = G(i,:)';
  R_W_0 = rpy2r(ob(1), ob(2), ob(3));
  g_base = (R_W_0')*g_world;
  % Drehmoment aus Gravitation im Vergleich mit Drehmoment aus
  % Basis-Beschleunigung
  Mqb = %RN%_inertia_joint_base_floatb_twist_slag_vp1(q, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tau_acc_floatb = (Mqb*[-g_base; zeros(3,1);]);
  tau_acc_grav = %RN%_gravload_joint_floatb_twist_slag_vp1(q, g_base, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  if any(abs(tau_acc_floatb - tau_acc_grav) > 1e-12)
    error('acceleration torque floating base and gravload do not match. %1.5e');
  end
end
fprintf('Tested acceleration torque based on floating base inertia and gravload for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Alle Funktionen mit Parametersatz 2 testen
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';
  qDD = QDD(i,:)';
  g_world = G(i,:)';
  V_W_W_0 = VB(i,:)';
  A_W_W_0 = AB(i,:)';
  
  ob = OB(i,:)';
  oDb = OBD(i,:)';
  oDDb = OBDD(i,:)';
  xDB = [V_W_W_0(1:3); oDb];
  xDDB = [A_W_W_0(1:3); oDDb];

  % Gravitationsmoment
  tau_b_par1 = %RN%_gravload_base_floatb_eulangrpy_slag_vp1(q, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  taug_b_par2 = %RN%_gravload_base_floatb_eulangrpy_slag_vp2(q, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, mrSges);
  if any(abs(tau_b_par1-taug_b_par2) > 1e-12)
    error('base gravitation force vectors do not match between par1/par2.');
  end
  
  % Coriolis
  tauc_j_par1 = %RN%_coriolisvec_joint_floatb_twist_slag_vp1(q, qD, V_W_W_0,...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tauc_j_par2 = %RN%_coriolisvec_joint_floatb_twist_slag_vp2(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tauc_j_par1-tauc_j_par2) > 1e-12)
    error('coriolis vectors do not match between par1/par2.');
  end
  tauc_g_par1 = %RN%_coriolisvec_floatb_eulangrpy_slag_vp1(q, qD, ob, xDB,...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tauc_g_par2 = %RN%_coriolisvec_floatb_eulangrpy_slag_vp2(q, qD, ob, xDB, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tauc_g_par1-tauc_g_par2) > 1e-12)
    error('coriolis vectors do not match between par1/par2.');
  end
  Cq_par1 = %RN%_coriolismat_joint_floatb_twist_slag_vp1(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  Cq_par2 = %RN%_coriolismat_joint_floatb_twist_slag_vp2(q, qD, V_W_W_0, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges); 
  if any(abs(Cq_par1(:)-Cq_par2(:)) > 1e-12)
    error('coriolis matrices do not match between par1/par2.');
  end 
  % Inverse Dynamics
  tau_par1 = %RN%_invdyn_joint_floatb_twist_slag_vp1(q, qD, qDD, V_W_W_0, A_W_W_0, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges, Icges);
  tau_par2 = %RN%_invdyn_joint_floatb_twist_slag_vp2(q, qD, qDD, V_W_W_0, A_W_W_0, g_world, ...
    alpha, a, d, q_offset, b, beta, m, mrSges, Ifges);
  if any(abs(tau_par1-tau_par2) > 1e-12)
    error('inverse dynamics joint torque vectors do not match between par1/par2.');
  end
end
fprintf('Tested Functions with parameter sets 1 and 2 for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Numerische Berechnung der Basis-Gravitationslast
for i = 1:n
  q = Q(i,:)';
  ob = OB(i,:)';
  ob([1 3]) = 0;
  r_W_W_0 = RB(i,:)';
  g_world = G(i,:)';
  
  
  % symbolische Berechnung
  Fg_base_sym = %RN%_gravload_base_floatb_eulangrpy_slag_vp1(q, ob, g_world, ...
    alpha, a, d, q_offset, b, beta, m, rSges);
  m(2:3) = 0;
  % numerische Berechnung
  % Kinematik aller Körperschwerpunkte berechnen
  T_c_mdh = %RN%_fkine_floatb_eulangrpy_rotmat_mdh_sym_varpar(q, r_W_W_0, ob, ...
  alpha, a, d, q_offset, b, beta);
  r_W_0_Si_ges = NaN(size(rSges));
  r_0_0_Si_ges = NaN(size(rSges));
  T_W_0 = T_c_mdh(:,:,1);
  R_W_0 = T_W_0(1:3,1:3);
  g_base = (R_W_0')*g_world;
  for jj = 1:size(rSges,1) % die durch Gelenke beweglichen Körper und die Basis
    R_W_jj = T_c_mdh(1:3,1:3,jj); % Rotation von Basis zum Körper-KS
    R_0_jj = R_W_0' * R_W_jj;
    T_W_jj = T_c_mdh(:,:,jj);
    T_0_jj = invtr(T_W_jj) * T_W_0;
    r_W_W_jj = T_W_jj(1:3,4); % Vektor von Basis zu Ursprung des Körper-KS
    r_0_0_jj = T_0_jj(1:3,4);
    r_0_0_Si = r_0_0_jj + R_0_jj*rSges(jj,:)'; % Vektor von Basis zu Körperschwerpunkt
    r_W_0_Si_ges(jj,:) = R_W_0 * r_0_0_Si;
    r_0_0_Si_ges(jj,:) = r_0_0_Si;
  end
  % Calculate Gravity Force
  Fg_base_num = zeros(6,1);
  % Kräfte
  Fg_base_num(1:3) = -sum(m)*g_base;
  % Momente
  Fg_base_num(4:6) = zeros(1,3);
  for jj = 1:size(rSges,1)
    Fg_base_num(4:6) = Fg_base_num(4:6) + cross(r_0_0_Si_ges(jj,:)', -m(jj)*g_base);
  end
  
  % Rotiere
  Fg_base_sym = rotate_wrench(Fg_base_sym, R_W_0');
  
  % wandle das Basismoment entlang der Eulerwinkel in ein Moment um die
  % Koordinatenachsen um
  T_basevel = rpy2jac(ob(1), ob(2), ob(3));
  Fg_base_sym_rot = [Fg_base_sym(1:3); zeros(3,1)];
  Fg_base_sym_rot(4:6) = [Fg_base_sym(4); 0; 0];
  Fg_base_sym_rot(4:6) = Fg_base_sym_rot(4:6) + rotx(ob(1))*[0; Fg_base_sym(5); 0];
  Fg_base_sym_rot(4:6) = Fg_base_sym_rot(4:6) + rotx(ob(1))*roty(ob(2))*[0; 0; Fg_base_sym(6)];
%   Fg_base_sym_rot(4:6) = T_basevel*Fg_base_sym(4:6);

  Fg_base_sym_rot(4:6) = R_W_0' * Fg_base_sym_rot(4:6);

  norm(Fg_base_sym(4:6)) - norm(Fg_base_num(4:6))

  e =  Fg_base_num - Fg_base_sym_rot 
  if any(abs( Fg_base_num - Fg_base_sym_rot ) > 1e-12)
    error('Numerische/symbolische Berechnung der Basis-Gewichtskraft stimmt nicht überein.');
  end
end
fprintf('Tested base gravload num/sym for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

