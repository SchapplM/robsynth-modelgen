% Teste Kinematik- und Dynamikfunktionen für %RN% mit denen aus %RNTE%
% Rechnet Kinematikterme von der geschlossenen auf die offene Struktur und
% rechnet Dynamikterme von der offenen auf die geschlossene Struktur um.

% Quellen:
% [NakamuraGho1989] Nakamura, Yoshihiko and Ghodoussi, Modjtaba: Dynamics computation of closed-link robot mechanisms with nonredundant and redundant actuators (1989)
% [Docquier2013] Docquier, Nicolas and Poncelet, Antoine and Fisette, Paul: ROBOTRAN: a powerful symbolic gnerator of multibody models (2013)

% %VERSIONINFO%

% Tim Job (HiWi-Job bei Moritz Schappler), 2019-05
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de
% (C) Institut für Mechatronische Systeme, Universität Hannover


clear
clc

%% Init

if isempty(fileparts(which('%RNTE%_varpar_testfunctions_parameter')))
    fprintf('Test für die impliziten ZB nicht ausgeführt, da die expliziten ZBs noch nicht vorliegen');
    return;
end



TSSc = %RNTE%_varpar_testfunctions_parameter; % mit Zwangsbedingungen
TSSo = %RN%_varpar_testfunctions_parameter; % ohne Zwangsbedingungen

% Dynamikparameter angleichen
TSSc.m = TSSo.m;
TSSc.rSges = TSSo.rSges;
TSSc.Icges = TSSo.Icges;
TSSc.mrSges = TSSo.mrSges;
TSSc.Ifges = TSSo.Ifges;

% Indizes zur Umrechnung von Gelenken von o zu c
% (für den offenen Kreis werden alle Gelenkvariablen ausgegeben, also auch
% die virtuellen Schnittgelenke)

[~, sigma_mdh, mu_mdh] = %RNOL%_structural_kinematic_parameters();

posNQJ = %RN%_positionVector_NQJ();
I_p = (mu_mdh==0);
I_a = (mu_mdh==1);

I_p = I_p(posNQJ==1);
I_a = I_a(posNQJ==1);

NQJ = TSSo.NQJ;
NQJA = sum(I_a==1);
NQJP = sum(I_p==1);

II_oc = find(posNQJ==1);

II_o1 = find(I_a==1);
II_o2 = find(I_p==1);

% Permutationsmatrizen zur Umrechnung von aufgeteilten Koordinaten
% (aktiv/passiv nacheinander) in Koordinaten der Baumstruktur (aktiv/passiv gemischt) 
P1 = zeros(NQJA,NQJ);
P2 = zeros(NQJP,NQJ);
for i = 1:NQJA
  P1(i,II_o1(i)) = 1;
end
for i = 1:NQJP
  P2(i,II_o2(i)) = 1;
end
P0 = ([P1;P2])'; % Permutationsmatrix K in [DoThanhKotHeiOrt2009b]

%% Berechnung der Zwangsbedingungs-Projektionsmatrix aus Impliziten ZB
% Nach [Docquier2013]

for iq = 1:TSSc.n
    g = TSSc.G(iq,:)';
    
    % Minimalkoordinaten für System mit ZB
    q1 = TSSc.Q(iq,:)';
    qD1 = TSSc.QD(iq,:)';
    qDD1 = TSSc.QDD(iq,:)';
    
    % Umrechnung von System mit ZB auf offenes System ohne ZB
    W = %RNTE%_kinconstr_expl_jacobian_mdh_sym_varpar(q1, TSSc.pkin);
    WD = %RNTE%_kinconstr_expl_jacobianD_mdh_sym_varpar(q1, qD1, TSSc.pkin);
    q = %RNTE%_kinconstr_expl_mdh_sym_varpar(q1, TSSc.pkin);
    
    q = q(posNQJ==1);
    W = W(posNQJ==1,:);
    WD = WD(posNQJ==1,:);
  
    qD = W*qD1;
    qDD = W*qDD1 + WD*qD1;
    
    % Teste implizite Zwangsbedingungen
    h = %RN%_kinconstr_impl_mdh_sym_varpar(q, TSSo.pkin)';
    if any(abs(h(:)) > 1e-10)
      error('Implizite Zwangsbedingungen werden nicht erfüllt!');
    end
    
    % Dynamik der offenen Kette
    tau = %RNOL%_invdynJ_fixb_slag_vp1(q, qD, qDD, g, ...
    TSSo.pkin, TSSo.m, TSSo.rSges, TSSo.Icges);
    
    % Dynamik der geschlossenen Kette aus Jacobi (Projektion)
    % [NakamuraGho1989], Gl. 5 
    tau1 = W' * tau;
    
    % Vergleich mit Lösung mit Elimination
    tau1_test = %RNTE%_invdynJ_fixb_slag_vp2(q1, qD1, qDD1, g, ...
    TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
    
    test = tau1-tau1_test;
    if any( abs(test(:)) > 1e6*eps(max(abs(tau1))) )
        error('Dynamik mit ZB-Jacobi stimmt nicht mit Dynamik aus Eliminations-Ansatz');
    end
    
    % Dynamik der geschlossenen Kette aus Implizit-Jacobi (Projektion)
    % Quelle: [Docquier2013]
    J1 = %RN%_kinconstr_impl_act_jacobian_mdh_sym_varpar(q, TSSo.pkin);
    JD1 = %RN%_kinconstr_impl_act_jacobianD_mdh_sym_varpar(q, qD, TSSo.pkin);
    
    J2 = %RN%_kinconstr_impl_pas_jacobian_mdh_sym_varpar(q, TSSo.pkin);
    JD2 = %RN%_kinconstr_impl_pas_jacobianD_mdh_sym_varpar(q, qD, TSSo.pkin);
    
    JD = [JD1, JD2]; % [Docquier2013], Gl. 10
    B21= -J2\J1; % [Docquier2013], Text nach Gl. 12
    B21D = (J2\JD2) * (J2\J1) - J2\JD1; % [DoThanhKotHeiOrt2009b], Gl. 20
    
    % Teste Geschwindigkeit
    % [Docquier2013], Gl. 14
    qD2 = B21*qD1;
    qD_impl = P0 * [qD1; qD2];
  
    if any(abs(qD_impl-qD) > 1e-10)
      error('Geschwindigkeiten stimmen nicht mit Herleitung über impliziter und expliziter ZB');
    end
    
    % Teste Beschleunigung
    % [Docquier2013], Gl. 15
    qDD2 = B21*qDD1 - J2\(JD*[qD1;qD2]);
    qDD_impl = P0 * [qDD1; qDD2];
  
  
    if any(abs(qDD_impl-qDD) > 1e-10)
      error('Beschleunigungen stimmen nicht zwischen Herleitung über impliziter und expliziter ZB');
    end
    
    % Teste inverse Dynamik
    % [Docquier2013], Gl. 12
    tauIC = P1*tau + B21'*P2*tau;
    
    test = tau1-tauIC;
    if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
        error('Dynamik aus TE-ZB-Jacobi stimmt nicht mit der aus IC-ZB-Jacobi Ã¼berein');
    end
    
    % Test symbolisch berechneter inverse Dynamik über impl. Zwangsbedingungen mit numerischer Projektion
    tauICs = %RN%_invdynJ_fixb_slag_vp1(q, qD, qDD, g, ...
    TSSo.pkin, TSSo.m, TSSo.rSges, TSSo.Icges);
    
    test = tauIC-tauICs;
    if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
        error('Dynamik symbolischer Berechnung stimmt nicht mit numerischer Ã¼berein');
    end
end

fprintf('Herleitung mit impliziter und expliziter Form der Zwangsbedingungen erfolgreich verglichen\n');
