% Teste Kinematik- und Dynamikfunktionen für %RN% mit und ohne Zwangsbedingungen
% Rechnet Kinematikterme von der geschlossenen auf die offene Struktur und
% rechnet Dynamikterme von der offenen auf die geschlossene Struktur um.

% Quellen:
% [NakamuraGho1989] Nakamura, Yoshihiko and Ghodoussi, Modjtaba: Dynamics computation of closed-link robot mechanisms with nonredundant and redundant actuators (1989)
% [ParkChoPlo1999] Park, FC and Choi, Jihyeon and Ploen, SR: Symbolic formulation of closed chain dynamics in independent coordinates
% [UdwadiaKal1992] Udwadia, Firdaus E and Kalaba, Robert E: A new perspective on constrained motion (1992)
% [Docquier2013] Docquier, Nicolas and Poncelet, Antoine and Fisette, Paul: ROBOTRAN: a powerful symbolic gnerator of multibody models (2013)

% %VERSIONINFO%

% Moritz Schappler, schappler@irt.uni-hannover.de, 2017-12
% (C) Institut für Regelungstechnik, Universität Hannover

clear
clc

%% Init

if ~isempty(fileparts(which('%RNTE%_varpar_testfunctions_parameter')))
    TSSc = %RNTE%_varpar_testfunctions_parameter; % mit Zwangsbedingungen
    TSSo = %RNOL%_varpar_testfunctions_parameter; % ohne Zwangsbedingungen
    
    % Dynamikparameter angleichen
    TSSc.m = TSSo.m;
    TSSc.rSges = TSSo.rSges;
    TSSc.Icges = TSSo.Icges;
    TSSc.mrSges = TSSo.mrSges;
    TSSc.Ifges = TSSo.Ifges;
    
    %% Test der Zwangsbedingungen mit Projektion der Gelenkmomente
    % Nach [NakamuraGho1989]
    
    for iq = 1:TSSc.n
        g = TSSc.G(iq,:)';
        
        % Minimalkoordinaten für System mit ZB
        q1 = TSSc.Q(iq,:)';
        qD1 = TSSc.QD(iq,:)';
        qDD1 = TSSc.QDD(iq,:)';
        
        % Umrechnung von System mit ZB auf offenes System ohne ZB
        W = %RNTE%_kinconstr_expl_jacobian_mdh_sym_varpar(q1, TSSc.pkin);
        WD = %RNTE%_kinconstr_expl_jacobianD_mdh_sym_varpar(q1, qD1, TSSc.pkin);
        q = %RNTE%_kinconstr_expl_mdh_sym_varpar(q1, TSSc.pkin);
        qD = W*qD1;
        qDD = W*qDD1 + WD*qD1;
        
        % Vergleiche Gelenk-Transformationsmatrizen
        Tc = %RNTE%_joint_trafo_rotmat_mdh_sym_varpar(q1, TSSc.pkin);
        Tu = %RNOL%_joint_trafo_rotmat_mdh_sym_varpar(q, TSSo.pkin);
        for jj = 1:TSSc.NJ
            test = Tc(:,:,jj)\Tu(:,:,jj) - eye(4);
            if any( abs(test(:)) > 1e-10 )
                [Tc(:,:,jj),Tu(:,:,jj)] %#ok<NOPTS>
                r2eulxyz(Tc(1:3,1:3,jj)' * Tu(1:3,1:3,jj))*180/pi %#ok<NOPTS>
                error('Gelenk-Transformation stimmt nicht');
            end
        end
        % Vergleiche KörperKS-Transformationsmatrizen
        Tcc = %RNTE%_fkine_fixb_rotmat_mdh_sym_varpar(q1, TSSc.pkin);
        Tcu = %RNOL%_fkine_fixb_rotmat_mdh_sym_varpar(q, TSSo.pkin);
        for jj = 1:TSSc.NL % 1=Basis
            test = Tcc(:,:,jj)\Tcu(:,:,jj) - eye(4);
            if any( abs(test(:)) > 1e-10 )
                [Tcc(:,:,jj),Tcu(:,:,jj)] %#ok<NOPTS>
                r2eulxyz(Tcc(1:3,1:3,jj)' * Tcu(1:3,1:3,jj))*180/pi %#ok<NOPTS>
                error('Transformation stimmt nicht');
            end
        end
        % Vergleiche Geschwindigkeit und Jacobi-Matrizen
        for jj = 1:TSSc.NL % 1=Basis
            r_i_i_C = rand(3,1); % Jacobi-Matrix für zufälligen Punkt
            Jgc = %RNTE%_jacobig_fixb_sym_varpar(q1, uint8(jj), r_i_i_C, TSSc.pkin);
            Jgo = %RNOL%_jacobig_fixb_sym_varpar(q, uint8(jj), r_i_i_C, TSSo.pkin);
            % Geschwindigkeit des Punktes mit/ohne ZB
            Vc = Jgc*qD1;
            Vo = Jgo*qD;
            if any( abs(Vc-Vo) > 1e-10 )
                error('Geschwindigkeit/Jacobi-Matrix stimmt nicht');
            end
        end
        
        % Dynamik der offenen Kette
        tau = %RNOL%_invdynJ_fixb_slag_vp1(q, qD, qDD, g, ...
        TSSo.pkin, TSSo.m, TSSo.mrSges, TSSo.Ifges);
        
        % Dynamik der geschlossenen Kette aus Jacobi (Projektion)
        % [NakamuraGho1989], Gl. 5
        tau1 = W' * tau;
        
        % Vergleich mit Lösung mit Elimination
        tau1_test = %RNTE%_invdynJ_fixb_slag_vp2(q1, qD1, qDD1, g, ...
        TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
        
        test = tau1-tau1_test;
        if any( abs(test(:)) > 1e6*eps(max(abs(tau1))) )
            error('Dynamik mit ZB-Jacobi stimmt nicht mit Dynamik aus Eliminations-Ansatz');
        end
        
        % Vergleich der Projektionsmatrizen aus DE und IC
        
        Phia = %RN%_kinconstr_impl_act_jacobian_mdh_sym_varpar(q, TSSo.pkin);
        PhiaD = %RN%_kinconstr_impl_act_jacobianD_mdh_sym_varpar(q, TSSo.pkin);
        Phip = %RN%_kinconstr_impl_pas_jacobian_mdh_sym_varpar(q, qD, TSSo.pkin);
        PhipD = %RN%_kinconstr_impl_pas_jacobianD_mdh_sym_varpar(q, qD, TSSo.pkin);
        
        B21 = -inv(Phip) * Phia;
        B21D = inv(Phip) * PhipD * inv(Phip) * Phia + (-inv(Phip) * PhiaD);
        
        tauIC = P1*tau + B12'*P2*tau;
        
        test = tau1-tauIC;
        if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
            error('Dynamik aus DE-ZB-Jacobi stimmt nicht mit der aus IC-ZB-Jacobi Ã¼berein');
        end
        
        
        
    end
    
    fprintf('Test der Zwangsbedingungen offen/geschlossen für %d Kombinationen nach [NakamuraGho1989] erfolgreich\n', TSSc.n);
    
    %% Test der Zwangsbedingungen mit Gauß'schem Prinzip des kleinsten Zwangs
    % Nach [UdwadiaKal1992]
    
    II = TSSc.Ind_depjoints; % Indizes n2 in n
    n = TSSo.NJ; % Anzahl Gelenke
    n1 = TSSc.NQJ; % Anzahl unabhängige Gelenke
    n2 = sum(II); % Anzahl abhängige Gelenke
    
    for iq = 1:TSSc.n
        g = TSSc.G(iq,:)';
        
        % Minimalkoordinaten für System mit ZB
        q1 = TSSc.Q(iq,:)';
        qD1 = TSSc.QD(iq,:)';
        
        % Umrechnung von System mit ZB auf offenes System ohne ZB
        W = %RNTE%_kinconstr_expl_jacobian_mdh_sym_varpar(q1, TSSc.pkin);
        WD = %RNTE%_kinconstr_expl_jacobianD_mdh_sym_varpar(q1, qD1, TSSc.pkin);
        % Gelenkposition und -geschwindigkeit ohne ZB
        q = %RNTE%_kinconstr_expl_mdh_sym_varpar(q1, TSSc.pkin);
        qD = W*qD1;
        
        % Zwangsbedingungen: Bestimme implizite Formulierung nach [Docquier2013]
        % aus expliziter Formulierung (siehe Aufzeichnungen Schappler, 19.12.2017)
        F = W(II,:);
        FD = WD(II,:);
        J = NaN(n2,n); % Aus der Zeitableitung der impliziten ZB nach den Koordinaten des offenen Systems
        JD = NaN(n2,n);
        J(:,~II) = -F;
        J(:,II) = eye(n2,n2);
        JD(:,~II) = -FD;
        JD(:,II) = zeros(n2,n2);
        
        % Zwangsbedingungen in Form aus [UdwadiaKal1992], Gl. (3) konvertieren
        % (mit Koeffizientenvergleich der ZB-Gleichung (siehe [Docquier2013]).
        A = J;
        b = -JD*qD;
        
        % Dynamik ohne ZB ([UdwadiaKal1992], Gl. (1), (2)
        M = %RNOL%_inertiaJ_slag_vp1(q, ...
        TSSo.pkin, TSSo.m, TSSo.rSges, TSSo.Icges);
        Q = -%RNOL%_invdynJ_fixb_slag_vp1(q, qD, qD*0, g, ...
        TSSo.pkin, TSSo.m, TSSo.rSges, TSSo.Icges);
        a = M \ Q;
        
        K = sqrtm(M) * pinv( A / sqrtm(M) ); % [UdwadiaKal1992] Text nach Gl. (5a')
        Qc = K*(b - A*(M\Q)); % [UdwadiaKal1992] Gl. (5b)
        
        % Beschleunigung des offenen Systems mit Kräften aus den Zwangsbedingungen
        qDD2 = M\(Q+Qc);
        
        % Referenzlösung: Beschleunigung des geschlossenen Systems (mit ZB)
        M1 = %RNTE%_inertiaJ_slag_vp2(q1, ...
        TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
        tau1 = %RNTE%_invdynJ_fixb_slag_vp2(q1, qD1, qD1*0, g, ...
        TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
        qDD1 = M1 \ (-tau1);
        qDD2_test = W*qDD1 + WD*qD1;
        
        test = qDD2 - qDD2_test;
        if any(abs(test) > 1e-8)
            error('Abgleich nach [UdwadiaKal1992] Fehlgeschlagen');
        end
    end
    
    fprintf('Test der Zwangsbedingungen offen/geschlossen für %d Kombinationen nach [UdwadiaKal1992] erfolgreich\n', TSSc.n);
else
    fprintf('Test für die impliziten ZB nicht ausgeführt, da die expliziten ZBs noch nicht vorliegen');
end