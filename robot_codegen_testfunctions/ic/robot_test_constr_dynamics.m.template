% Teste Kinematik- und Dynamikfunktionen für %RN% mit denen aus %RNTE%
% Rechnet Kinematikterme von der geschlossenen auf die offene Struktur und
% rechnet Dynamikterme von der offenen auf die geschlossene Struktur um.

% Quellen:
% [NakamuraGho1989] Nakamura, Yoshihiko and Ghodoussi, Modjtaba: Dynamics computation of closed-link robot mechanisms with nonredundant and redundant actuators (1989)
% [Docquier2013] Docquier, Nicolas and Poncelet, Antoine and Fisette, Paul: ROBOTRAN: a powerful symbolic gnerator of multibody models (2013)

% %VERSIONINFO%

% Tim Job (HiWi-Job bei Moritz Schappler), 2019-05
% Moritz Schappler, moritz.schappler@imes.uni-hannover.de
% (C) Institut für Mechatronische Systeme, Universität Hannover


clear
clc

%% Init

if isempty(fileparts(which('%RNTE%_varpar_testfunctions_parameter')))
    fprintf('Test für die impliziten ZB nicht ausgeführt, da die expliziten ZBs noch nicht vorliegen\n');
    return;
end



TSSc = %RNTE%_varpar_testfunctions_parameter; % mit Zwangsbedingungen
TSSo = %RNOL%_varpar_testfunctions_parameter; % ohne Zwangsbedingungen

% Dynamikparameter angleichen
TSSc.m = TSSo.m;
TSSc.rSges = TSSo.rSges;
TSSc.Icges = TSSo.Icges;
TSSc.mrSges = TSSo.mrSges;
TSSc.Ifges = TSSo.Ifges;

% Indizes zur Umrechnung von Gelenken von o zu c
% (für den offenen Kreis werden alle Gelenkvariablen ausgegeben, also auch
% die virtuellen Schnittgelenke)

[~, sigma_mdh, mu_mdh] = %RNOL%_structural_kinematic_parameters();

posNQJ = %RN%_positionVector_NQJ();
I_p = (mu_mdh==0);
I_a = (mu_mdh==1);

I_p = I_p(posNQJ==1);
I_a = I_a(posNQJ==1);

NQJ = TSSo.NQJ;
NQJA = sum(I_a==1);
NQJP = sum(I_p==1);

II_oc = find(posNQJ==1);

II_o1 = find(I_a==1);
II_o2 = find(I_p==1);

% Permutationsmatrizen zur Umrechnung von aufgeteilten Koordinaten
% (aktiv/passiv nacheinander) in Koordinaten der Baumstruktur (aktiv/passiv gemischt) 
P1 = zeros(NQJA,NQJ);
P2 = zeros(NQJP,NQJ);
for i = 1:NQJA
  P1(i,II_o1(i)) = 1;
end
for i = 1:NQJP
  P2(i,II_o2(i)) = 1;
end
P0 = ([P1;P2])'; % Permutationsmatrix K in [DoThanhKotHeiOrt2009b]

%% Berechnung der Zwangsbedingungs-Projektionsmatrix aus Impliziten ZB
% Nach [Docquier2013]

for iq = 1:TSSc.n
    g = TSSc.G(iq,:)';
    
    % Minimalkoordinaten für System mit ZB
    q1 = TSSc.Q(iq,:)';
    qD1 = TSSc.QD(iq,:)';
    qDD1 = TSSc.QDD(iq,:)';
    
    % Umrechnung von System mit ZB auf offenes System ohne ZB
    W = %RNTE%_kinconstr_expl_jacobian_mdh_sym_varpar(q1, TSSc.pkin);
    WD = %RNTE%_kinconstr_expl_jacobianD_mdh_sym_varpar(q1, qD1, TSSc.pkin);
    q = %RNTE%_kinconstr_expl_mdh_sym_varpar(q1, TSSc.pkin);
    
    q = q(posNQJ==1);
    W = W(posNQJ==1,:);
    WD = WD(posNQJ==1,:);
  
    qD = W*qD1;
    qDD = W*qDD1 + WD*qD1;
    
    % Teste implizite Zwangsbedingungen
    h = %RN%_kinconstr_impl_mdh_sym_varpar(q, TSSo.pkin);
    if any(abs(h) > 1e-10)
      error('Implizite Zwangsbedingungen werden nicht erfüllt!');
    end
    
    % Vergleiche Gelenk-Transformationsmatrizen
    Tc = %RNTE%_joint_trafo_rotmat_mdh_sym_varpar(q1, TSSc.pkin);
    Tu = %RNOL%_joint_trafo_rotmat_mdh_sym_varpar(q, TSSo.pkin);
    for jj = 1:TSSc.NJ 
      test = Tc(:,:,jj)\Tu(:,:,jj) - eye(4);
      if any( abs(test(:)) > 1e-10 )
        [Tc(:,:,jj),Tu(:,:,jj)] %#ok<NOPTS>
        r2eulxyz(Tc(1:3,1:3,jj)' * Tu(1:3,1:3,jj))*180/pi %#ok<NOPTS>
        error('Gelenk-Transformation stimmt nicht');
      end
    end
    % Vergleiche KörperKS-Transformationsmatrizen
    Tcc = %RNTE%_fkine_fixb_rotmat_mdh_sym_varpar(q1, TSSc.pkin);
    Tcu = %RNOL%_fkine_fixb_rotmat_mdh_sym_varpar(q, TSSo.pkin);
    for jj = 1:TSSc.NL % 1=Basis
      test = Tcc(:,:,jj)\Tcu(:,:,jj) - eye(4);
      if any( abs(test(:)) > 1e-10 )
        [Tcc(:,:,jj),Tcu(:,:,jj)] %#ok<NOPTS>
        r2eulxyz(Tcc(1:3,1:3,jj)' * Tcu(1:3,1:3,jj))*180/pi %#ok<NOPTS>
        error('Transformation stimmt nicht');
      end
    end
    
    % Dynamik der offenen Kette
    tau = %RNOL%_invdynJ_fixb_slag_vp2(q, qD, qDD, g, ...
    TSSo.pkin, TSSo.m, TSSo.mrSges, TSSo.Ifges);
    
    % Dynamik der geschlossenen Kette aus Jacobi (Projektion)
    % [NakamuraGho1989], Gl. 5 
    tau1 = W' * tau;
    
    % Vergleich mit Lösung mit Elimination
    tau1_test = %RNTE%_invdynJ_fixb_slag_vp2(q1, qD1, qDD1, g, ...
    TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
    
    test = tau1-tau1_test;
    if any( abs(test(:)) > 1e6*eps(max(abs(tau1))) )
        error('Dynamik mit ZB-Jacobi stimmt nicht mit Dynamik aus Eliminations-Ansatz');
    end
    
    % Dynamik der geschlossenen Kette aus Implizit-Jacobi (Projektion)
    % Quelle: [Docquier2013]
    J1 = %RN%_kinconstr_impl_act_jacobian_mdh_sym_varpar(q, TSSo.pkin);
    JD1 = %RN%_kinconstr_impl_act_jacobianD_mdh_sym_varpar(q, qD, TSSo.pkin);
    
    J2 = %RN%_kinconstr_impl_pas_jacobian_mdh_sym_varpar(q, TSSo.pkin);
    JD2 = %RN%_kinconstr_impl_pas_jacobianD_mdh_sym_varpar(q, qD, TSSo.pkin);
    
    JD = [JD1, JD2]; % [Docquier2013], Gl. 10
    B21= -J2\J1; % [Docquier2013], Text nach Gl. 12
    B21D = (J2\JD2) * (J2\J1) - J2\JD1; % [DoThanhKotHeiOrt2009b], Gl. 20
    
    % Teste Geschwindigkeit
    % [Docquier2013], Gl. 14
    qD2 = B21*qD1;
    qD_impl = P0 * [qD1; qD2];
  
    if any(abs(qD_impl-qD) > 1e-10)
      error('Geschwindigkeiten stimmen nicht mit Herleitung über impliziter und expliziter ZB');
    end
    
    % Teste Beschleunigung
    % [Docquier2013], Gl. 15
    qDD2 = B21*qDD1 - J2\(JD*[qD1;qD2]);
    qDD_impl = P0 * [qDD1; qDD2];
  
  
    if any(abs(qDD_impl-qDD) > 1e-10)
      error('Beschleunigungen stimmen nicht zwischen Herleitung über impliziter und expliziter ZB');
    end
    
    % Teste inverse Dynamik
    % [Docquier2013], Gl. 12
    tauIC = P1*tau + B21'*P2*tau;
    
    test = tau1-tauIC;
    if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
        error('Dynamik aus TE-ZB-Jacobi stimmt nicht mit der aus IC-ZB-Jacobi Ã¼berein');
    end
    
    % Test symbolisch berechneter inverse Dynamik über impl. Zwangsbedingungen mit numerischer Projektion
    tauICs = %RN%_invdynJ_fixb_slag_vp2(q, qD, qDD, g, ...
    TSSo.pkin, TSSo.m, TSSo.mrSges, TSSo.Ifges);
    
    test = tauIC-tauICs;
    if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
        error('Dynamik symbolischer Berechnung stimmt nicht mit numerischer Ã¼berein');
    end
    
    % Test inverse Dynmik Newton-Euler vs Lagrange
    tauICs_snew = %RN%_invdynJ_fixb_snew_vp2(q, qD, qDD, g, ...
    TSSo.pkin, TSSo.m, TSSo.mrSges, TSSo.Ifges);
    
    test = tauICs_snew-tauICs;
    if any( abs(test(:)) > 1e6*eps(max(abs(W))) )
        error('Dynamik Newton-Euler stimmt nicht mit Lagrange überein');
    end
    
    % Test Gravitationsmoment
    taug1_expl = %RNTE%_gravloadJ_floatb_twist_slag_vp2(q1, g, TSSc.pkin, TSSc.m, TSSc.mrSges);
    taug1_impl = %RN%_gravloadJ_floatb_twist_slag_vp2(q, g, TSSo.pkin, TSSo.m, TSSo.mrSges);
    
    if any(abs(taug1_expl-taug1_impl) > 1e-10)
        error('Gravitationsmoment mit ZB-Jacobi stimmt nicht mit Gravitationsmoment aus Eliminations-Ansatz');
    end
    

    % Test Gravitationsmoment mit Newton-Euler
    taug1_snew_impl = %RN%_gravloadJ_floatb_twist_snew_vp2(q, g, TSSo.pkin, TSSo.m, TSSo.mrSges);
    
    if any(abs(taug1_snew_impl-taug1_impl) > 1e-10)
        error('Gravitationsmoment mit ZB-Jacobi und Newton-Euler stimmt nicht mit Gravitationsmoment aus Lagrange');
    end
    
    % Test Massenmatrix
    MM1_impl = %RN%_inertiaJ_slag_vp2(q, TSSo.pkin, TSSo.m, TSSo.mrSges, TSSo.Ifges);
    MM1_expl = %RNTE%_inertiaJ_slag_vp2(q1, TSSc.pkin, TSSc.m, TSSc.mrSges, TSSc.Ifges);
    
    test = MM1_impl - MM1_expl;
    if any( abs(test(:)) > 1e6*eps(1+max(abs(test))) )
      error('Massenmatrix mit ZB-Jacobi stimmt nicht mit Massenmatrix aus Eliminations-Ansatz');
    end
end

fprintf('Herleitung mit impliziter und expliziter Form der Zwangsbedingungen erfolgreich verglichen\n');
