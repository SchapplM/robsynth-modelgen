% Start the forward dynamics model (fixed base)
% * no initial velocity
% * random starting pose
% * no joint damping. Check for energy consistency

% Moritz Schappler, schappler@irt.uni-hannover.de, 2016-04
% (c) Institut für Regelungstechnik, Universität Hannover

clear
clc
close all

this_path = fileparts( mfilename('fullpath') );
if ~isempty(this_path), cd(this_path); end

%% Init
% Standard-Einstellungen laden
%RN%_fdyn_floatb_eulangrpy_test_settings_default

%% modify default settings

%% Start Simulation
t1 = tic;
simOut = sim(sl_Modellname, 'StopTime', '10', ...
  'SimulationMode', 'normal'); % normal
sl = get_simulink_outputs(simOut, sl_Modellname);
fprintf('Simulink-Modell berechnet. Rechenzeit: %1.1fs\n', toc(t1));

%% Test

R_base_t0 = rpy2r(phi_base_t0(1), phi_base_t0(2), phi_base_t0(3) );
quat_base_t0 = r2quat(R_base_t0)
rpy_base_t0_test = r2rpy(R_base_t0)
omega_base_t0 = rpyD2omega(phi_base_t0', phiD_base_t0')
rpyDD2omegaD(phi_base_t0', phiD_base_t0', zeros(1,3))

xD_base_t0 = [rD_base_t0; phiD_base_t0];

Mq = %RN%_inertia_floatb_eulangrpy_slag_vp1(qJ_t0, phi_base_t0, ...
  alpha, a, d, q_offset, b, beta, m, rSges, Icges);
tauc = %RN%_coriolisvec_floatb_eulangrpy_slag_vp1(qJ_t0, qJD_t0, phi_base_t0, xD_base_t0, ...
  alpha, a, d, q_offset, b, beta, m, rSges, Icges);
taug_base = %RN%_gravload_base_floatb_eulangrpy_slag_vp1(qJ_t0, phi_base_t0, g_world, ...
  alpha, a, d, q_offset, b, beta, m, rSges);
taug_joints = %RN%_gravload_joint_floatb_eulangrpy_slag_vp1(qJ_t0, phi_base_t0, g_world,...
  alpha, a, d, q_offset, b, beta, m, rSges);
taug = [taug_base; taug_joints];

tau_acc = Mq \ (-tauc - taug)
tau_acc(1:3)
tau_acc(4:6)
tau_acc(7:8)

T = %RN%_energykin_floatb_eulangrpy_slag_vp1(qJ_t0, qJD_t0, phi_base_t0, xD_base_t0, ...
  alpha, a, d, q_offset, b, beta, m, rSges, Icges);
U = %RN%_energypot_floatb_eulangrpy_slag_vp1(qJ_t0, r_base_t0, phi_base_t0, g_world, ...
  alpha, a, d, q_offset, b, beta, m, rSges);


sl.r_base(1,:)
sl.phi_base(1,:)
sl.xD_base(1,:)


%% Plot
PlotSettings = struct('atlas_version', uint8(5));

figure(1);clf;
plot(sl.t, [sl.E, sum(sl.E,2)]);
legend({'T', 'U', 'Ges'});
ylabel('Energie');
grid on;

figure(2);clf;
subplot(3,1,1);
plot(sl.t, sl.qJ);
ylabel('q');grid on;
subplot(3,1,2);
plot(sl.t, sl.qJD);
ylabel('qD');grid on;
subplot(3,1,3);
plot(sl.t, sl.qJDD);
ylabel('qDD');grid on;

figure(3);clf;
subplot(3,2,sprc2no(3,2,1,1));
plot(sl.t, sl.r_base);
ylabel('r');grid on;
subplot(3,2,sprc2no(3,2,2,1));
plot(sl.t, sl.rD_base);
ylabel('rD');grid on;
subplot(3,2,sprc2no(3,2,3,1));
plot(sl.t, sl.rDD_base);
ylabel('rDD');grid on;

subplot(3,2,sprc2no(3,2,1,2));
plot(sl.t, sl.phi_base);
ylabel('phi');grid on;
subplot(3,2,sprc2no(3,2,2,2));
plot(sl.t, sl.phiD_base);
ylabel('phiD');grid on;
subplot(3,2,sprc2no(3,2,3,2));
plot(sl.t, sl.phiDD_base);
ylabel('phiDD');grid on;

E_minmax = minmax( sum(sl.E([1,end],:), 2) );
E_diff = E_minmax(1) - E_minmax(2);
if abs(E_diff) > 1e-6
  error('Nicht energiekonsistent');
else
  fprintf('Energiekonsistent\n');
end
