% Test function for inverse dynamics from symbolic calculations
% 
% Quellen:
% [KhalilDombre2002] Modeling, Identification and Control of Robots

% %VERSIONINFO%

% Moritz Schappler, schappler@irt.uni-hannover.de, 2016-03
% (C) Institut für Regelungstechnik, Universität Hannover

clc
clear

NQJ = %NQJ%;
NJ = %NJ%;
NL = %NL%;
robot_name = '%RN%';

%% Parameter
TSS = %RN%_varpar_testfunctions_parameter();
for f = fields(TSS)'
  eval(sprintf('%s=TSS.%s;',f{1},f{1}));
end
% Es werden fixed-base Funktionen getestet. Der Basis-Körper wird also mit
% NaN belegt und darf keinen Einfluss haben.
%% Test kinetic Energy
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';
  % calculate kinetic energy with optimized function
  T_func = %RN%_energykin_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  % calculate kinetic energy with mass matrix
  Mq = %RN%_inertiaJ_slag_vp1(q, ...
    pkin, m, rSges, Icges);
  T_M = 1/2 * qD' * Mq*qD;

  % compare both
  Delta = T_func-T_M;
  if any(abs(Delta) > 1e6*eps(T_func))
    error('Kinetic Energy from Mass Matrix does not match with directly calculated. %1.5e', ...
      max(abs(Delta)));
  end
end
fprintf('Tested kinetic energy/inertia for %d random joint angles for %s\n', ...
  n, robot_name);


%% Test coriolis vector and Matrix
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';

  % calculate coriolis vector directly from optimized function
  cq = %RN%_coriolisvecJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);

  % calculate with coriolis matrix
  Cq = %RN%_coriolismatJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  cq_mat = (Cq*qD);

  % compare both
  Delta = cq-cq_mat;
  if any( abs(Delta) > 1e6*eps(max(abs(cq))) )
    error('coriolis torques from vector and matrix do not match. %1.5e', ...
      max(abs(Delta)));
  end

end
fprintf('Tested coriolis vector/matrix for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Teste Massenmatrix-Zeitableitung gegen Coriolis-Matrix
% [KhalilDombre2002] p. 198 9.3.3.3 e)
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';

  % Coriolis Matrix
  Cq = %RN%_coriolismatJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);

  % Inertia Matrix time derivative
  MqD = %RN%_inertiaDJ_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);

  % Calculate test expression
  Test = MqD-2*Cq;

  % Test skew symmetry of Test-Matrix
  for ii = 1:NQJ
    for jj = 1:NQJ
      if abs(Test(ii,jj) + Test(jj,ii)) > 1e6*eps(max(abs(Cq(:))))
        error('Test-Matrix is not skew-symmetric');
      end
    end
  end
end
fprintf('Tested Inertia time derivative/coriolis matrix for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Alle Funktionen mit Parametersatz 2 testen
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';
  qDD = QDD(i,:)';
  g_base = G(i,:)';
  % Gravitation
  taug_par1 = %RN%_gravloadJ_floatb_twist_slag_vp1(q, g_base, ...
    pkin, m, rSges);
  taug_par2 = %RN%_gravloadJ_floatb_twist_slag_vp2(q, g_base, ...
    pkin, m, mrSges);
  if any( abs(taug_par1 - taug_par2) > 1e6*eps(max(abs(taug_par1))) )
    error('gravity torques do not match between par1/par2.');
  end
  % Coriolis
  tauc_par1 = %RN%_coriolisvecJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  tauc_par2 = %RN%_coriolisvecJ_fixb_slag_vp2(q, qD, ...
    pkin, m, mrSges, Ifges);
  if any( abs(tauc_par1-tauc_par2) > 1e6*eps(max(abs(tauc_par1))) )
    error('coriolis vectors do not match between par1/par2.');
  end
  Cq_par1 = %RN%_coriolismatJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  Cq_par2 = %RN%_coriolismatJ_fixb_slag_vp2(q, qD, ...
    pkin, m, mrSges, Ifges); 
  if any( abs(Cq_par1(:)-Cq_par2(:)) > 1e6*eps(max(abs(Cq_par1(:)))) )
    error('coriolis matrices do not match between par1/par2.');
  end 
  % Inertia
  Mq_par1 = %RN%_inertiaJ_slag_vp1(q, ...
    pkin, m, rSges, Icges);
  Mq_par2 = %RN%_inertiaJ_slag_vp2(q, ...
    pkin, m, mrSges, Ifges);
  if any( abs(Mq_par1(:)-Mq_par2(:)) > 1e6*eps(max(abs(Mq_par1(:)))) )
    error('inertia matrices do not match between par1/par2.');
  end
  % Inverse Dynamics
  tau_par1 = %RN%_invdynJ_fixb_slag_vp1(q, qD, qDD, g_base, ...
    pkin, m, rSges, Icges);
  tau_par2 = %RN%_invdynJ_fixb_slag_vp2(q, qD, qDD, g_base, ...
    pkin, m, mrSges, Ifges);
  if any( abs(tau_par1-tau_par2) > 1e6*eps(max(abs(tau_par1))) )
    error('inverse dynamics joint torque vectors do not match between par1/par2.');
  end
  % Potentielle Energie
  U_par1 = %RN%_energypot_fixb_slag_vp1(q, g_base, ...
    pkin, m, rSges);
  U_par2 = %RN%_energypot_fixb_slag_vp2(q, g_base, ...
    pkin, m, mrSges);
  if any(abs(U_par1-U_par2) > 1e6*eps(U_par1))
    error('Potential energies do not match between par1/par2.');
  end
  % Kinetische Energie
  T_par1 = %RN%_energykin_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  T_par2 = %RN%_energykin_fixb_slag_vp2(q, qD, ...
    pkin, m, mrSges, Ifges);
  if any(abs(T_par1-T_par2) > 1e6*eps(T_par1))
    error('Kinetic energies do not match between par1/par2.');
  end
end
fprintf('Tested Functions with parameter sets 1 and 2 for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Komplettfunktion für inverse Dynamik prüfen
for i = 1:n
  q = Q(i,:)';
  qD = QD(i,:)';
  qDD = QDD(i,:)';
  g_base = G(i,:)';
  % Gravitation
  taug_id = %RN%_invdynJ_fixb_slag_vp1(q, zeros(NQJ,1), zeros(NQJ,1), g_base, ...
    pkin, m, rSges, Icges);
  taug_sp = %RN%_gravloadJ_floatb_twist_slag_vp1(q, g_base, ...
    pkin, m, rSges);
  Delta = taug_id - taug_sp;
  if any(abs(Delta) > 1e6*eps(max(abs(taug_id))) )
    error('gravity torques from inverse dynamics and dedicated function do not match. %1.5e', ...
      max(abs(Delta)));
  end
  
  % Coriolis
  tauc_id = %RN%_invdynJ_fixb_slag_vp1(q, qD, zeros(NQJ,1), zeros(3,1), ...
    pkin, m, rSges, Icges);
  tauc_sp = %RN%_coriolisvecJ_fixb_slag_vp1(q, qD, ...
    pkin, m, rSges, Icges);
  Delta = tauc_id - tauc_sp;
  if any(abs(Delta) > 1e6*eps(max(abs(tauc_id))) )
    error('Coriolis torques from inverse dynamics and dedicated function do not match. %1.5e', ...
      max(abs(Delta)));
  end
  
  % Inertia
  taua_id = %RN%_invdynJ_fixb_slag_vp1(q, zeros(NQJ,1), qDD, zeros(3,1), ...
    pkin, m, rSges, Icges);
  Mq = %RN%_inertiaJ_slag_vp1(q, ...
    pkin, m, rSges, Icges);
  taua_sp = Mq*qDD;
  Delta = taua_id - taua_sp;
  if any(abs(Delta) > 1e6*eps(max(abs(taua_sp))) )
    error('Inertial torques from inverse dynamics and dedicated function do not match. %1.5e', ...
      max(abs(Delta)));
  end
end
fprintf('Tested inverse dynamics for %d random joint angles for %s\n', ...
  size(Q, 1), robot_name);

%% Energetische Konsistenz prüfen
n = 5; % Unterschiedliche Anfangskonfigurationen
t_End = 1;
for ii = 1:n
  q0 = Q(ii,:)';
  qD0 = QD(ii,:)';
  g_base = G(ii,:)';

  % Zustand des Systems (Position und Geschwindigkeit)
  x0 = [q0; qD0];
  % Funktion zur Berechnung der Beschleunigung (Inverse Massenmatrix
  % multipliziert mit Beschleunigungsmoment)
  odefun = @(t, x) ([x(NQJ+1:2*NQJ); -%RN%_inertiaJ_slag_vp1(x(1:NQJ), ...
    pkin, m, rSges, Icges) ...
    \ ...
    (%RN%_invdynJ_fixb_slag_vp1(x(1:NQJ), x(NQJ+1:2*NQJ), zeros(NQJ,1), [0;0;-9.81], pkin, m, rSges, Icges))]);
  odefun(0, x0); % Testen der Funktion
  % Numerische Integration konfigurieren und durchführen
  options = odeset('MaxStep',1e-3); % mit automatischer Schrittweite ist der Fehler zu groß
  SolverOutput = ode45(odefun,[0 t_End],x0, options);
  t = SolverOutput.x;
  % Berechne Energie aus den Ausgaben
  E = NaN(length(t), 3);
  tau_Acc = NaN(length(t), NQJ);
  for i = 1:length(t)
    q = SolverOutput.y(1:NQJ,i);
    qD = SolverOutput.y(NQJ+1:2*NQJ,i);
    E(i,1) = %RN%_energykin_fixb_slag_vp1(q, qD, pkin, m, rSges, Icges);
    E(i,2) = %RN%_energypot_fixb_slag_vp1(q, [0;0;-9.81], pkin, m, rSges);
    tau_Acc(i,:) = %RN%_invdynJ_fixb_slag_vp1(q, qD, zeros(NQJ,1), [0;0;-9.81], pkin, m, rSges, Icges)';
  end
  E(:,3) = sum(E(:,1:2),2); % Gesamtenergie
  % Ergebnisse zeichnen
  figure(1);clf;
  subplot(2,2,1);
  plot(t, E);ylabel('Energie [J]');legend({'T', 'U', 'Ges'});
  title(sprintf('Energie: %s', robot_name), 'interpreter', 'none');
  subplot(2,2,2);
  plot(t, SolverOutput.y(1:NQJ,:)'); ylabel('Gelenkwinkel [rad]');
  subplot(2,2,3);
  plot(t, SolverOutput.y(NQJ+1:2*NQJ,:)'); ylabel('Geschwindigkeit [rad/s]');
  subplot(2,2,4);
  plot(t, tau_Acc); ylabel('Beschleunigungsmoment [Nm]');

  if abs(E(1,3) - E(end,3)) > 5e-4
    error('Das System ist nicht energetisch konsistent');
  end
end
fprintf('Tested energetic consistency for free movement with %d starting configurations for %s\n', ...
  n, robot_name);

